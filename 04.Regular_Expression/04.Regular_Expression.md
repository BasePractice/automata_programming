## Регулярные выражения

Регулярные выражения - формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов.

Материал взят из стати [Реализация механизма обработки регулярных выражений на языке C++](http://rus-linux.net/nlib.php?name=/MyLDP/algol/cpattern/Regular_Expressions_in_C_ru.html)

### Ссылки

1. [Online RE](https://regexr.com/)
2. [RE to NFA](https://cyberzhg.github.io/toolbox/nfa2dfa)

### Принципы

В первую очередь, рассмотрим несколько принципов поиска по шаблону с помощью `РВ`.

Для указания шаблона вы должны использовать форму записи, которую может обработать компьютер. Эта форма записи, или язык, в нашем случае - синтаксис `РВ`.

Язык `РВ` состоит из литералов и метасимволов. Литералы - это обычный текст, являющийся частью шаблона. Для описания отношений между литералами применяются следующие метасимволы (от имеющих наивысший приоритет к имеющим наименьший):
1. Квантификаторы (`closure`): строка одинаковых литералов, длина которой может меняться, либо литерал, появление которого не обязательно. (Одна из важнейших составляющих поиска по шаблону.)
2. Конкатенация (`concatenation`): Если в шаблоне два литерала, идущих друг за другом, то и в тексте будет осуществлён поиск символов, идущих друг за другом.
3. Объединение (конструкция выбора, `alteration`): Один из литералов, между которыми осуществляется выбор должен находиться в тексте, сравниваемом с шаблоном.
В дополнение к вышеперечисленному, использование скобок позволяет влиять на последовательность обработки элементов `РВ`.

В большинстве реализаций обработчиков `РВ`, квантификаторы включают:
1. звёздочку (`*`), означающую повторение литерала нуль или более раз
2. плюс (`+`), означающий повторение литерала один или более раз
3. знак вопроса (`?`), означающий, что наличие того или иного литерала возможно, но не является обязательным условием совпадения шаблона с текстом
Примеры: `A*` совпадает с пустой строкой, `"A"`, `"AA"`, `"AAA"` и т. д., `A+` совпадает с `"A"`, `"AA"`, `"AAA"` и т. д. `A?` совпадает с пустой строкой или `"A"`.

Для задания конкатенации нет необходимости использовать метасимволы. Строка, содержащая идущие друг за другом символы, является конкатенацией. Регулярное выражение `ABC`, например, совпадёт со строкой `"ABC"`.

Объединение (конструкция выбора, `alteration`) задаётся с помощью символа `"|"` между двумя `РВ`. `A|B` совпадает либо с `"A"`, либо с `"B"`.

### Синтаксис

#### Обычные символы

Большинство символов в регулярном выражении представляют сами себя за исключением специальных символов `[ ] \ / ^ $ . | ? * + ( ) { }` , которые могут быть экранированы символом `\` (обратная косая черта) для представления самих себя в качестве символов текста. Можно экранировать целую последовательность символов, заключив её между `\Q` и `\E`.

Пример     |	Соответствие
-----------|-------------
`a\.?`	   | a. или a
`a\\\\b`   |	a\\b
`a\[F\] `  |	a[F]
`\Q+-*/\E` |	+-*/

Аналогично могут быть представлены другие специальные символы (набор символов, требующих экранирования, может отличаться в зависимости от конкретной реализации). Часть символов, которые в той или иной реализации не требуют экранирования (например, угловые скобки `< >`), могут быть экранированы из соображений удобочитаемости.

#### Любой символ

Метасимвол `.` (точка) означает один любой символ, но в некоторых реализациях исключая символ новой строки.

Вместо символа `.` можно использовать `[\s\S]` (все пробельные и непробельные символы, включая символ новой строки).

#### Символьные классы

Набор символов в квадратных скобках `[ ]` именуется символьным классом и позволяет указать интерпретатору регулярных выражений, что на данном месте в строке может стоять один из перечисленных символов. В частности, `[абв]` задаёт возможность появления в тексте одного из трёх указанных символов, а `[1234567890]` задаёт соответствие одной из цифр. Возможно указание диапазонов символов: например, `[А-Яа-я]` соответствует всем буквам русского алфавита, за исключением букв `«Ё»` и `«ё»`.

Если требуется указать символы, которые не входят в указанный набор, то используют символ `^` внутри квадратных скобок, например `[^0-9]` означает любой символ, кроме цифр.

Некоторые символьные классы можно заменить специальными метасимволами:

Символ |	Эквивалент    |	Соответствие
-------|----------------|--------------
`\d`	 |`[0-9]`	        | Цифровой символ
`\D`	 |`[^0-9]`	      | Нецифровой символ
`\s`	 |`[ \f\n\r\t\v]`	| Пробельный символ
`\S`	 |`[^ \f\n\r\t\v]`|	Непробельный символ
`\w`	 |`[[:word:]]`	  | Буквенный или цифровой символ или знак подчёркивания
`\W`	 |`[^[:word:]]`	  | Любой символ, кроме буквенного или цифрового символа или знака подчёркивания

#### Позиция внутри строки

Следующие символы позволяют спозиционировать регулярное выражение относительно элементов текста: начала и конца строки, границ слова.

Представление | Позиция
--------------|--------
`^`	          | Начало текста (или строки при модификаторе `?m`)
`$`	          | Конец текста (или строки при модификаторе `?m`)
`\b`	        | Граница слова
`\B`	        | Не граница слова
`\G`	        | Предыдущий успешный поиск


#### Обозначение группы

Круглые скобки используются для определения области действия и приоритета операций. Шаблон внутри группы обрабатывается как единое целое и может быть квантифицирован. Например, выражение `(тр[ау]м-?)*` найдёт последовательность вида `трам-трам-трумтрам-трум-трамтрум`

#### Перечисление

Вертикальная черта разделяет допустимые варианты. Например, `gray|grey` соответствует `gray` или `grey`. Следует помнить, что перебор вариантов выполняется слева направо, как они указаны.

Если требуется указать перечень вариантов внутри более сложного регулярного выражения, то его нужно заключить в группу. Например, `gray|grey` или `gr(a|e)y` описывают строку `gray` или `grey`. В случае с односимвольными альтернативами предпочтителен вариант `gr[ae]y`, так как сравнение с символьным классом выполняется проще, чем обработка группы с проверкой на все её возможные модификаторы и генерацией обратной связи.

#### Квантификация

Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. Следует учитывать, что квантификатор может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.

Представление |	Число повторений |	Эквивалент
--------------|------------------|------------
`?`	          | Ноль или одно	   | `{0,1}`
`*`	          | Ноль или более	 | `{0,}`
`+`	          | Одно или более	 | `{1,}`

Представление | Число повторений
--------------|-----------------
`{n}`	        | Ровно `n` раз
`{m,n}`	      | От `m` до `n` включительно
`{m,}`	      | Не менее `m`
`{,n}`	      | Не более `n`

Часто используется последовательность `.*` для обозначения любого количества любых символов между двумя частями регулярного выражения.

#### Жадность

Жадный   |	Ленивый
---------|---------
`*`	     | `*?`
`+`	     | `+?`
`{n,}`	 | `{n,}?`

Также общей проблемой как жадных, так и ленивых выражений являются точки возврата для перебора вариантов выражения. Точки ставятся после каждой итерации квантификатора. Если интерпретатор не нашёл соответствия после квантификатора, то он начинает возвращаться по всем установленным точкам, пересчитывая оттуда выражение по-другому.

#### Ревнивая жадность

В отличие от обычной (жадной) квантификации, ревнивая (`possessive`) квантификация не только старается найти максимально длинный вариант, но ещё и не позволяет алгоритму возвращаться к предыдущим шагам поиска для того, чтобы найти возможные соответствия для оставшейся части регулярного выражения.

Использование ревнивых квантификаторов увеличивает скорость поиска, особенно в тех случаях, когда строка не соответствует регулярному выражению. Кроме того, ревнивые квантификаторы могут быть использованы для исключения нежелательных совпадений.

Жадный	  | Ревнивый
----------|---------
`*`	      | `*+`
`?`	      | `?+`
`+`	      | `++`
`{n,}`	  | `{n,}+`

`ab(xa)*+a`	над **abxaa** bxaa, но не abxa **abxaa**, так как буква `a` уже занята

### Автомат
Для поиска шаблона, заданного `РВ`, вы не можете сравнивать каждый символ шаблона с каждым символом текста. Квантификаторы и объединение вызывают к жизни такое количество путей срабатывания сложных шаблонов, что использование "обычного" алгоритма невозможно. Должен быть применен более действенный подход. Лучший путь - построить автомат и смоделировать его работу. Для описания поискового шаблона, заданного регулярным выражением, вы можете использовать недетерминированный и детерминированный конечные автоматы.

Автомат может переходить в несколько состояний. Он может переходить из одного состояния в другое, в зависимости от события, которое поступило ему на вход, в нашем случае, - очередной входной символ. Здесь же видна разница между детерминированными и недетерминированными конечными автоматами. Детерминированный автомат может принять только одно состояние в ответ на определённый символ, а недетерминированный автомат может перейти в одно из нескольких состояний в ответ на один и тот же входной символ.

Оба типа автоматов допустимо использовать для задания любого `РВ`. Каждый из этих типов автоматов имеет достоинства и недостатки. Для всех, кто хочет знать больше об этих автоматах в их связи с `РВ`. В нашей реализации мы будем использовать недетерминированный автомат. Это наиболее востребованная стратегия реализации алгоритма обработки `РВ`. Более того, сконструировать недетерминированный автомат по РВ несколько проще, чем детерминированный.

На рисунке показана диаграмма переходов недетерминированного конечного автомата для шаблона `a*(cb|c*)d`. Она содержит все типы операций над регулярными множествами: итерацию, конкатенацию, объединение. Заметьте, что скобка, содержащая объединение, является литералом для операции конкатенации. Начальное состояние представлено прямоугольником в левой части рисунка. Допускающее состояние автомата показано в правой части рисунка в виде прямоугольника, перечёркнутого по диагонали.

![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/a_cb_c_d.png)

Этот пример очень хорошо демонстрирует проблемы обработки шаблонов. В состоянии под номером `7` не ясно какое состояние будет следующим для входного символа `"c"`. Состояния `4` и `9` - возможные варианты. Автомат должен выбрать правильный путь.

Если на предмет совпадения с шаблоном должна быть исследована строка, содержащая текст `"aaccd"`, автомат стартует из состояния номер `0` - начального состояния. Следующее состояние, номер `2`, является нулевым. Иными словами, для перехода автомата в это состояние не нужны символы, совпадающие с шаблоном.

Первый символ на входе - `"a"`. Автомат переходит в состояние под номером `1`, это единственный путь. После успешного совпадения части шаблона с символом `"a"` будет прочитан очередной символ и автомат снова перейдёт в состояние `2`. Для следующего входного символа, тоже `"a"`, крайние два перехода повторяются. После этого, единственный допустимый путь - переход в состояние под номером `3` и `7`.

Мы оказались в состоянии, которое может вызвать проблемы. Следующий символ на входе - `"c"`. Здесь мы видим силу автомата. Он может догадаться, что правильный путь будет через состояние номер `9`, но не `4`. Это - душа недетерминированной стратегии: возможные решения находятся. Они не описываются алгоритмом, работающим "шаг за шагом".

Разумеется, в реальном мире программирования мы должны перебирать все возможные пути. Однако, о практической стороне дела поговорим несколько позже.

После достижения состояния под номером `9`, автомат осуществляет переход из `9` в `8` (первое `"c"` на входе), в `9`, в `8` (второе `"c"` на входе), `10` и `11` (совпадение с `"d"`) в допускающее состояние под номером `12`. Допускающее состояние достигнуто, следовательно, текст `"aaccd"` совпадает с шаблоном "`a*(cb|c*)d"`.



### Примеры типичных регулярных выражений

Материал взят [8 Regular expressions you should know](https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149)

#### Matching a Hex Value

Pattern `/^#?([a-f0-9]{6}|[a-f0-9]{3})$/`
![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/hex_value.jpg)

#### Matching an Email

Pattern `/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/`
![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/email.jpg)

#### Matching a URL

Pattern `/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/`
![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/url.jpg)

#### Matching an IP Address
Pattern `/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`
![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/ip.jpg)

#### Matching an HTML Tag
Pattern `/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/`
![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/htmltag.jpg)

### Шпаргалка

![RE](https://raw.githubusercontent.com/BasePractice/automata_programming/develop/04.Regular_Expression/regexp.png)


## RegExp machine

[Building a RegExp machine. Part 1: Regular grammars](https://medium.com/@DmitrySoshnikov/building-a-regexp-machine-part-1-regular-grammars-d4986b585d7e)
[Building a RegExp machine. Part 2: Finite automata — NFA fragments](https://medium.com/@DmitrySoshnikov/building-a-regexp-machine-part-2-finite-automata-nfa-fragments-5a7c5c005ef0)
