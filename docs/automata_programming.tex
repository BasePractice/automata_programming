\documentclass[12pt, twoside]{report}
\usepackage[a4paper, top=3cm, bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1,T2A,TS1]{fontenc}
\usepackage[russian]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{color}
\usepackage{footnote}
\usepackage{url}
\usepackage{babelbib}
\usepackage{array,longtable}
\usepackage{fontenc}
\usepackage{mathtext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[pdftex]{graphicx}
\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{cite}
\usepackage{longtable}
\usepackage{listings}
\usepackage{lipsum}
\usepackage[none]{hyphenat}
\usepackage[hypcap]{caption}
\usepackage{pdflscape}
\usepackage[citecolor = blue]{hyperref}
\usepackage{alltt}
\usepackage{ifxetex}
\usepackage[final]{pdfpages}
\usepackage{wrapfig}
\usepackage{epigraph}
%%\usepackage{svg}
%------------------Font specification-------------------%
% If you want to use font other than the default one,
% you MUST use XeLaTeX to compile.
\ifxetex
\usepackage{fontspec}
\usepackage{xunicode}
% Use Monaco as default font, change down below (if you wish).
\newfontfamily{\monaco}{Monaco} % Replace "Monaco" with another font name.
\else
\newcommand{\monaco}{\ttfamily }
\fi

\renewcommand{\lstlistingname}{Код}
\newcommand{\mysinglespacing}{%
\setstretch{1}% no correction afterwards
}


%\setlength{\hoffset}{1.5 cm}
%\setlength{\voffset}{-2 em}
%\setlength{\topmargin}{0 cm}
%\setlength{\headheight}{1 em}
%\setlength{\headsep}{1 em}
%\setlength{\oddsidemargin}{0 cm}
%\setlength{\textwidth}{16 cm}
%\setlength{\textheight}{24.7 cm}


\lstloadlanguages{C++}
\definecolor{nsclass}{RGB}{124,32,176}
\definecolor{atnotation}{RGB}{27, 103, 224}
\definecolor{import}{RGB}{128,70,30}
\definecolor{comment}{RGB}{0,140,0}
\definecolor{string}{RGB}{229,0,0}
\definecolor{method}{RGB}{70,0,134}
\definecolor{class}{RGB}{59,131,138}
\definecolor{custommethod}{RGB}{32,90,95}
\definecolor{number}{RGB}{56,0,225}
\definecolor{customgray}{RGB}{211,211,211}
\definecolor{namespaces}{RGB}{2, 153, 19}
\definecolor{number}{RGB}{227, 146, 7}
\lstset{
language=C++, tabsize=2, keepspaces=false,
xleftmargin=0em,xrightmargin=-1em, aboveskip=1em, % Margin adjustment
%backgroundcolor=\color{customgray},    % Background color (Default:gray)
%backgroundcolor=none,
 frame=none,                            % Frame not needed
breakindent=22pt,
 inputencoding=utf8,
 extendedchars=true,
%numbers=left,stepnumber=1,numberstyle=\tiny\color{black}\monaco,
basicstyle=\mysinglespacing\fontsize{11.5pt}{1em}\selectfont\monaco,
commentstyle=\fontsize{11.5pt}{0.75em}\selectfont\monaco\color{comment},
showspaces=false,
flexiblecolumns=true,
breaklines=true,
 %breakautoindent=true, breakindent=4em,
escapeinside={/*@}{@*/},
morecomment=[s][\color{string}]{"}{"},
 morecomment=[s][\color{string}]{'}{'},
morecomment=[l][\color{import}]{\#},
morecomment=**[s][\color{nsclass}]{NS}{];},
morecomment=**[s][\color{nsclass}]{UI}{];},
morecomment=**[s][\color{nsclass}]{NS}{(},
morecomment=**[s][\color{nsclass}]{UI}{)},
morecomment=**[s][\color{nsclass}]{UI}{*},
morecomment=**[s][\color{nsclass}]{NS}{*},
morecomment=*[s][\color{nsclass}]{UI}{\ },
morecomment=*[s][\color{nsclass}]{NS}{\ },
}
% Down below, you can add your custom class names / method names as presented
% in your source code.
% For example, you have two custom class names called User and Person.
% You should add in the list User, Person
% The list of names should be seperated by commas, and no quotation
% marks are required.
\lstset{
emph=[1]{  % <--Add your own Class Names before the percentage mark
cout, cin, cerr, endl
},
emphstyle=[1]{\color{class}},
emph=[2]{ % <--Add your namespaces
std
},
emphstyle=[2]{\color{namespaces}},
moreemph=[5]{ % <--Add your own Method Names before the percentage mark
},
emphstyle=[5]{\color{method}},
}

\lstset{
emph=[3]{
 @implementation,@synthesize, @interface, @property, @dynamic,
@end, break, case, catch, class, operator, copy, const, __finally, __exception,
__try, const_cast, continue, private, public, protected, __declspec,
default, delete, deprecated, dllexport, dllimport, do, dynamic_cast, else,
enum, explicit, extern, if, for, friend, getter, goto, inline, mutable,
naked, namespace, new, nil, NO, noinline, nonatomic, noreturn, nothrow,
NULL, readonly, readwrite, register, reinterpret_cast, retain, return,
SEL, selectany, self, setter, sizeof, static, static_cast, struct, super,
switch, template, thread, throw, true, false, try, typedef, typeid,
typename, union, using, uuid, virtual, void, volatile, whcar_t, while, YES,
ATOM, BOOL, BOOLEAN, BYTE, CHAR, COLORREF, DWORD, DWORDLONG, DWORD_PTR,
DWORD32,DWORD64, FLOAT, HACCEL, HALF_PTR, HANDLE, HBITMAP, HBRUSH,
HCOLORSPACE, HCONV, HCONVLIST, HCURSOR, HDC, HDDEDATA, HDESK, HDROP,
HDWP, HENHMETAFILE, HFILE, HFONT, HGDIOBJ, HGLOBAL, HHOOK, HICON,
HINSTANCE, HKEY, HKL, HLOCAL, HMENU, HMETAFILE, HMODULE, HMONITOR,
HPALETTE, HPEN, HRESULT, HRGN, HRSRC, HSZ, HWINSTA, HWND, INT, INT_PTR,
INT32, INT64, LANGID, LCID, LCTYPE, LGRPID, LONG, LONGLONG, LONG_PTR,
LONG32, LONG64, LPARAM, LPBOOL, LPBYTE, LPCOLORREF, LPCSTR, LPCTSTR,
LPCVOID, LPCWSTR, LPDWORD, LPHANDLE, LPINT, LPLONG, LPSTR, LPTSTR, LPVOID,
LPWORD, LPWSTR, LRESULT, PBOOL, PBOOLEAN, PBYTE, PCHAR, PCSTR, PCTSTR,
PCWSTR, PDWORDLONG, PDWORD_PTR, PDWORD32, PDWORD64, PFLOAT, PHALF_PTR,
PHANDLE, PHKEY, PINT, PINT_PTR, PINT32, PINT64, PLCID, PLONG, PLONGLONG,
PLONG_PTR, PLONG32, PLONG64, POINTER_32, POINTER_64, PSHORT, PSIZE_T,
PSSIZE_T, PSTR, PTBYTE, PTCHAR, PTSTR, PUCHAR, PUHALF_PTR, PUINT, PUINT_PTR,
PUINT32, PUINT64, PULONG, PULONGLONG, PULONG_PTR, PULONG32, PULONG64, PUSHORT,
PVOID, PWCHAR, PWORD, PWSTR, SC_HANDLE, SC_LOCK, SERVICE_STATUS_HANDLE,
SHORT, SIZE_T, SSIZE_T, TBYTE, TCHAR, UCHAR, UHALF_PTR, UINT, UINT_PTR,
UINT32, UINT64, ULONG, ULONGLONG, ULONG_PTR, ULONG32, ULONG64, USHORT,
USN, VOID, WCHAR, WORD, WPARAM, WPARAM, WPARAM, char, bool, short, int, unsigned,
__int32, __int64, __int8, __int16, long, float, double, __wchar_t, clock_t,
_complex, _dev_t, _diskfree_t, div_t, ldiv_t, _exception, _EXCEPTION_POINTERS,
FILE, _finddata_t, _finddatai64_t, _wfinddata_t, _wfinddatai64_t,
__finddata64_t,
__wfinddata64_t, _FPIEEE_RECORD, fpos_t, _HEAPINFO, _HFILE, lconv, intptr_t,
id, jmp_buf, mbstate_t, _off_t, _onexit_t, _PNH, ptrdiff_t,
_purecall_handler, sig_atomic_t, size_t, _stat, __stat64, _stati64,
terminate_function, time_t, __time64_t, _timeb, __timeb64, tm, uintptr_t,
_utimbuf, va_list, wchar_t, wctrans_t, wctype_t, wint_t, signed,
	STD_OUTPUT_HANDLE, COORD, CONSOLE_SCREEN_BUFFER_INFO, WIN32, _WIN32, _UNICODE,
	UNICODE, ILLEGAL_HANDLE_VALUE, stdout, stderr, stdin, EXIT_SUCCESS, LC_ALL, SEEK_SET,
	SEEK_END, SEEK_CUR, EXIT_FAILURE, errno, BUFSIZE, EOF, FILENAME_MAX, FOPEN_MAX, TMP_MAX, TRUE, FALSE,
pthread_mutex_t, pthread_t, sem_t, time_t
},
	emphstyle=[3]{\color{atnotation}},
moreemph=[4]{
 alloc, init, NSLog, sqrt, pow, cbrt, abs, fabs, powf, atoi,
 malloc, free, calloc, realloc,
 fprintf, fopen, fclose, feof, ftell, fwind, fseek, fscanf, fgetc, fgets, ferror, clearerr,
 freopen, rewind, fsetpos, fgetpos, remove, rename, tmpfile, tmpnam, fflush, setbuf, setvbuf,
 fputc, fputs,
 printf, scanf, getch, gets, snprintf, sprintf, sscanf, vfprintf, vfscanf, getc, getchar,
 putchar, puts, ungetc,
 main,
 memset, memcpy, memcmp,
 strlen, strcmp, strncmp, strcpy, strcat, strncpy, strncat, strchr, strrchr,
 strstr, strpbrk, strspn, strcspn, strtok, strdup, strerror, perror,
 GetStdHandle, GetConsoleScreenBufferInfo, FillConsoleOutputCharacter,
 SetConsoleWindowInfo, SetConsoleCursorPosition,
 system, setlocale, exit,
pthread_mutex_unlock, pthread_mutex_lock, pthread_create, pthread_join,
pthread_exit,
sem_init, sem_post, sem_wait,
sleep, usleep, time
},
	emphstyle=[4]{\color{method}}
}

\lstset{literate=%
{0}{{{\color{number}0}}}1
{1}{{{\color{number}1}}}1
{2}{{{\color{number}2}}}1
{3}{{{\color{number}3}}}1
{4}{{{\color{number}4}}}1
{5}{{{\color{number}5}}}1
{6}{{{\color{number}6}}}1
{7}{{{\color{number}7}}}1
{8}{{{\color{number}8}}}1
{9}{{{\color{number}9}}}1
}
\newcommand{\cname}[1] {
\textcolor{atnotation}{#1}
}
\newcommand{\cstring}[1] {
\textcolor{string}{"#1"}
}
\graphicspath{{graph/}{images/}}
\begin{document}
\pagestyle{empty}
\title{\textbf{Автоматное программирование}}
\author{Хлебников Андрей Александрович}
\date{\today}

%-------------------------------------------------------------------------------
\maketitle
\pagestyle{empty}
\newpage
\renewcommand{\cftchapdotsep}{\cftdotsep}
\tableofcontents
%\addcontentsline{toc}{tableofcontents}{Оглавление}
\newpage
%-------------------------------------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\lhead[]{\thepage}
\rhead[\thepage]{}

\pagenumbering{arabic}
\singlespacing
%-------------------------------------------------------------------------------

\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}


Автоматное программирование, по сравнению с другими распространенными подходами к 
разработке сложных программных систем имеет много недостатков \nameref{kuznetcov_about}, 
но также и ряд преимуществ которые будут освещены далле в этом курсе.

Подход к разработке сложных программных систем был построен на основе подхода А. А. Шалыто\cite{Shalito:AutomataProgramming} и 
состоит из следующих этапов:
\begin{enumerate}
  \item Создание схемы связей блока управления с объектом управления и системой верхнего уровня.
  \item Разработка перечня и описания входных и выходных переменных.
  \item Получение алгоритма работы исходя из поставленной задачи.
  \item Эвристическое проектирование системы графов переходов конечных автоматов.
  \item Описание модели Promela.
  \item Верификация модели (с дополнительной проверкой LTL* соотвествия спецификации).
  \item Описание проекта, кодирование при помощи языка Си.
  \item Написание тестов (эмуляторов устройств) проверки работоспособности периферийных модулей системы.
\end{enumerate}

Существуют также языки автоматного программирования, результатом работы которых является программный 
код на различных языках, например \texttt{FSML}\cite{Lagunov:FSML}.

\chapter*{Парадигмы программирования}
\addcontentsline{toc}{chapter}{Парадигмы программирования}

\section*{Императивное программирование}

Императивное программирование -- это парадигма программирования (стиль написания исходного кода компьютерной программы), для которой характерно следующее:

\begin{itemize}
  \item в исходном коде программы записываются инструкции (команды);
  \item инструкции должны выполняться последовательно;
  \item при выполнении инструкции данные, полученные при выполнении предыдущих инструкций, могут читаться из памяти;
  \item данные, полученные при выполнении инструкции, могут записываться в память.
\end{itemize}

Императивная программа похожа на приказы (англ. \textbf{imperative} -- приказ, повелительное наклонение), выражаемые повелительным наклонением в естественных языках, то есть представляют собой последовательность команд, которые должен выполнить компьютер.

При императивном подходе к составлению кода (в отличие от функционального подхода, относящегося к декларативной парадигме) широко используется присваивание. Наличие операторов присваивания увеличивает сложность модели вычислений и делает императивные программы подверженными специфическим ошибкам, не встречающимся при функциональном подходе\footnote{Harold Abelson, Jerry Sussman, and Julie Sussman: Structure and Interpretation of Computer Programs (MIT Press, 1984; ISBN 0-262-01077-1), Pitfalls of imperative programming}.

Основные черты императивных языков:
\begin{itemize}
  \item использование именованных переменных;
  \item использование оператора присваивания;
  \item использование составных выражений;
  \item использование подпрограмм;
\end{itemize}

История:
Первыми императивными языками были машинные инструкции (коды) - команды, готовые к исполнению компьютером сразу (без каких-либо преобразований). В дальнейшем были созданы ассемблеры, и программы стали записывать на языках ассемблеров. Ассемблер - компьютерная программа, предназначенная для преобразования машинных инструкций, записанных в виде текста на языке, понятном человеку (языке ассемблера), в машинные инструкции в виде, понятном компьютеру (машинный код). Одной инструкции на языке ассемблера соответствовала одна инструкция на машинном языке. Разные компьютеры поддерживали разные наборы инструкций. Программы, записанные для одного компьютера, приходилось заново переписывать для переноса на другой компьютер. Были созданы языки программирования высокого уровня и компиляторы - программы, преобразующие текст с языка программирования на язык машины (машинный код). Одна инструкция языка высокого уровня соответствовала одной или нескольким инструкциям языка машины, и для разных машин эти инструкции были разными. Первым распространённым высокоуровневым языком программирования, получившим применения на практике, стал язык Fortran

\section*{Декларативное программирование}

Декларативное программирование -- это парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается, что представляет собой проблема и ожидаемый результат. Противоположностью декларативного является императивное программирование, описывающее на том или ином уровне детализации, как решить задачу и представить результат. В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное - от машины к человеку. Как следствие, декларативные программы не используют понятия состояния, то есть не содержат переменных и операторов присваивания (см. также ссылочная прозрачность).

Наиболее близким к <<чисто декларативному>> программированию является написание исполнимых спецификаций (см. соответствие Карри - Ховарда). В этом случае программа представляет собой формальную теорию, а её выполнение является одновременно автоматическим доказательством этой теории, и характерные для императивного программирования составляющие процесса разработки (проектирование, рефакторинг, отладка и др.) в этом случае исключаются: программа проектирует и доказывает сама себя.

К подвидам декларативного программирования также зачастую относят функциональное и логическое программирование - несмотря на то, что программы на таких языках нередко содержат алгоритмические составляющие, архитектура в императивном понимании (как нечто отдельное от кодирования) в них также отсутствует: схема программы является непосредственно частью исполняемого кода(http://fprog.ru/2010/issue6/interview-simon-peyton-jones/).

На повышение уровня декларативности нацелено языково-ориентированное программирование.

<<Чисто декларативные>> компьютерные языки зачастую не полны по Тьюрингу - примерами служат SQL и HTML - так как теоретически не всегда возможно порождение исполняемого кода по декларативному описанию. Это иногда приводит к спорам о корректности термина <<декларативное программирование>> (менее спорным является <<декларативное описание решения>> или, что то же самое, <<декларативное описание задачи>>).

\section*{Структурное программирование}

Структурное программирование -- методология разработки программного обеспечения, в основе которой лежит представление программы в виде иерархической структуры блоков. Предложена в 1970-х годах Э. Дейкстрой и др.

В соответствии с данной методологией любая программа строится без использования оператора goto из трёх базовых управляющих структур: последовательность, ветвление, цикл; кроме того, используются подпрограммы. При этом разработка программы ведётся пошагово, методом <<сверху вниз>>.

Методология структурного программирования появилась как следствие возрастания сложности решаемых на компьютерах задач, и соответственно, усложнения программного обеспечения. В 1970-е годы объёмы и сложность программ достигли такого уровня, что традиционная (неструктурированная) разработка программ перестала удовлетворять потребностям практики. Программы становились слишком сложными, чтобы их можно было нормально сопровождать. Поэтому потребовалась систематизация процесса разработки и структуры программ.

Методология структурной разработки программного обеспечения была признана <<самой сильной формализацией 70-х годов>>.

По мнению Бертрана Мейера, <<Революция во взглядах на программирование, начатая Дейкстрой, привела к движению, известному как структурное программирование, которое предложило систематический, рациональный подход к конструированию программ. Структурное программирование стало основой всего, что сделано в методологии программирования, включая и объектное программирование>>\footnote{Мейер Б. Почувствуй класс. Учимся программировать хорошо с объектами и контрактами. - Пер. с англ. - М.: Национальный открытый университет ИНТУИТ: БИНОМ. Лаборатория знаний, 2011. - 775с. - С. 208. - ISBN 978-5-9963-0573-5}

Цель структурного программирования - повысить производительность труда программистов, в том числе при разработке больших и сложных программных комплексов, сократить число ошибок, упростить отладку, модификацию и сопровождение программного обеспечения.

\section*{Функциональное программирование}

Функциональное программирование -- раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).

Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).

На практике отличие математической функции от понятия <<функции>> в императивном программировании заключается в том, что императивные функции могут опираться не только на аргументы, но и на состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять состояние внешних переменных. Таким образом, в императивном программировании при вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных. А в функциональном языке при вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных. Это позволяет средам выполнения программ на функциональных языках кешировать результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо дополнительных действий со стороны программиста (что обеспечивают функции без побочных эффектов - чистые функции).

Лямбда-исчисление являются основой для функционального программирования, многие функциональные языки можно рассматривать как <<надстройку>> над ними\footnote{А. Филд, П. Харрисон Функциональное программирование: Пер. с англ. - М.: Мир, 1993. - 637 с, ил. ISBN 5-03-001870-0. Стр. 120 [Глава 6: Математические основы: Лямбда-исчисление]}.

Пример(Erlang):
\begin{alltt}
proc(Function, List, Number) ->
    process_flag(trap_exit, true),
    Supervisor = self(),
    spawn_link(combinat, Function, [List, Number, fun(R)->Supervisor!R end]),
    loop([]).

loop(Total) ->
    receive
    {'EXIT', Worker, normal} ->
        io:format("~w~n", [Total]),
        unlink(Worker);
    Result ->
        loop(Total ++ [Result])
    end.
\end{alltt}
\section*{Логическое программирование}
	
Логическое программирование -- парадигма программирования, основанная на автоматическом доказательстве теорем, а также раздел дискретной математики, изучающий принципы логического вывода информации на основе заданных фактов и правил вывода. Логическое программирование основано на теории и аппарате математической логики с использованием математических принципов резолюций.

Самым известным языком логического программирования является Prolog.

\section*{Объектно-ориентированное программирование}

Объектно-ориентированное программирование (ООП) -- методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования\footnote{Гради Буч. Объектно-ориентированный анализ и проектирование с примерами приложений на С++. 2-е издание, Издательство: Бином, Невский Диалект, 1998, ISBN 0-8053-5340-2, ISBN 5-7989-0067-3, ISBN 5-7940-0017-1}.

Идеологически ООП - подход к программированию как к моделированию информационных объектов, решающий на новом уровне основную задачу структурного программирования: структурирование информации с точки зрения управляемости\footnote{Edsger W. Dijkstra Программирование как вид человеческой деятельности. 1979 (EWD117)}, что существенно улучшает управляемость самим процессом моделирования, что в свою очередь особенно важно при реализации крупных проектов.

Управляемость для иерархических систем предполагает минимизацию избыточности данных (аналогичную нормализации) и их целостность, поэтому созданное удобно управляемым - будет и удобно пониматься. Таким образом через тактическую задачу управляемости решается стратегическая задача - транслировать понимание задачи программистом в наиболее удобную для дальнейшего использования форму.

Основные принципы структурирования в случае ООП связаны с различными аспектами базового понимания предметной задачи, которое требуется для оптимального управления соответствующей моделью:

- абстрагирование для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счете - контекстное понимание предмета, формализуемое в виде класса;
- инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды <<что делать>>, без одновременного уточнения как именно делать, так как это уже другой уровень управления;
- наследование для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя все остальное, учтенное на предыдущих шагах;
- полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот - собрать воедино.

То есть фактически речь идет о прогрессирующей организации информации согласно первичным семантическим критериям: <<важное/неважное>>, <<ключевое/подробности>>, <<родительское/дочернее>>, <<единое/множественное>>. Прогрессирование, в частности, на последнем этапе дает возможность перехода на следующий уровень детализации, что замыкает общий процесс.

Обычный человеческий язык в целом отражает идеологию ООП, начиная с инкапсуляции представления о предмете в виде его имени и заканчивая полиморфизмом использования слова в переносном смысле, что в итоге развивает\footnote{Л.В. Успенский. "Слово о словах". - 5-е изд. - Л.: Детская литература (Ленинградское отделение), 1971} выражение представления через имя предмета до полноценного понятия-класса.

\section*{Процедурное программирование}

Процедурное программирование -- программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка\footnote{Хювёнен, Сеппянен, 1990, т. 2, с. 27.}.

Процедурное программирование является отражением архитектуры традиционных ЭВМ, которая была предложена Фон Нейманом в 1940-х годах. Теоретической моделью процедурного программирования служит абстрактная вычислительная система под названием машина Тьюринга.

\section*{Автоматное программирование}

Автоматное программирование -- это парадигма программирования, при использовании которой программа или её фрагмент осмысливается как модель какого-либо формального автомата. Известна также и другая "парадигма автоматного программирования, состоящая в представлении сущностей со сложным поведением в виде автоматизированных объектов управления, каждый из которых представляет собой объект управления и автомат". При этом о программе, как в автоматическом управлении, предлагается думать как о системе автоматизированных объектов управления.

В зависимости от конкретной задачи в автоматном программировании могут использоваться как конечные автоматы, так и автоматы с более сложным строением.

Определяющими для автоматного программирования являются следующие особенности:

временной период выполнения программы разбивается на шаги автомата, каждый из которых представляет собой выполнение определённой (одной и той же для каждого шага) секции кода с единственной точкой входа; такая секция может быть оформлена, например, в виде отдельной функции и может быть разделена на подсекции, соответствующие отдельным состояниям или категориям состояний
передача информации между шагами автомата осуществляется только через явно обозначенное множество переменных, называемых состоянием автомата; между шагами автомата программа (или её часть, оформленная в автоматном стиле) не может содержать неявных элементов состояния, таких как значения локальных переменных в стеке, адреса возврата из функций, значение текущего счётчика команд и т. п.; иначе говоря, состояние программы на любые два момента входа в шаг автомата могут различаться между собой только значениями переменных, составляющих состояние автомата (причём такие переменные должны быть явно обозначены в качестве таковых).
Полностью выполнение кода в автоматном стиле представляет собой цикл (возможно, неявный) шагов автомата.

Название автоматное программирование оправдывается ещё и тем, что стиль мышления (восприятия процесса исполнения) при программировании в этой технике практически точно воспроизводит стиль мышления при составлении формальных автоматов (таких как машина Тьюринга, автомат Маркова и др.)

Сфера применения:
Автоматное программирование широко применяется при построении лексических анализаторов (классические конечные автоматы) и синтаксических анализаторов (автоматы с магазинной памятью)\footnote{А. Ахо, Дж. Ульман. Теория синтаксического анализа, перевода и компиляции = The theory of parsing, translation and compiling. - М.: МИР, 1978. - Т. 1. - 612 с}.

Кроме того, мышление в терминах конечных автоматов (то есть разбиение исполнения программы на шаги автомата и передача информации от шага к шагу через состояние) необходимо при построении событийно-ориентированных приложений. В этом случае программирование в стиле конечных автоматов оказывается единственной альтернативой порождению множества процессов или потоков управления (тредов).

Часто понятие состояний и машин состояний используется для спецификации программ. Так, при проектировании программного обеспечения с помощью UML для описания поведения объектов используются диаграммы состояний (state machine diagrams). Кроме того, явное выделение состояний используется в описании сетевых протоколов (см., например, RFC 793\footnote{Postel, J., ed., Transmission Control Protocol, RFC 793}).

Мышление в терминах автоматов (шагов и состояний) находит применение и при описании семантики некоторых языков программирования. Так, исполнение программы на языке Рефал представляет собой последовательность изменений поля зрения Рефал-машины или, иначе говоря, последовательность шагов Рефал-автомата, состоянием которого является содержимое поля зрения (произвольное Рефал-выражение, не содержащее переменных).

Механизм продолжений языка Scheme для своей реализации также требует мышления в терминах состояний и шагов, несмотря на то что сам язык Scheme никоим образом не является автоматным. Тем не менее, чтобы обеспечить возможность <<замораживания>> продолжения, приходится при реализации вычислительной модели языка Scheme объединять все компоненты среды исполнения, включая список действий, которые осталось выполнить для окончания вычислений, в единое целое, которое также обычно называется продолжением. Такое продолжение оказывается состоянием автомата, а процесс выполнения программы состоит из шагов, каждый из которых выводит следующее значение продолжения из предыдущего.

Александр Оллонгрен в своей книге[3] описывает так называемый Венский метод описания семантики языков программирования, основанный целиком на формальных автоматах.

В качестве одного из примеров применения автоматной парадигмы можно назвать систему STAT\footnote{А. Ахо, Дж. Ульман. Теория синтаксического анализа, перевода и компиляции = The theory of parsing, translation and compiling. - М.: МИР, 1978. - Т. 1. - 612 с.}; эта система, в частности, включает встроенный язык STATL, имеющий чисто автоматную семантику.

Существуют также предложения по использованию автоматного программирования в качестве универсального подхода к созданию компьютерных программ вне зависимости от предметной области. Так, авторы статьи\footnote{Туккель Н.И., Шалыто А.А. Программирование с явным выделением состояний // Мир ПК. - 2001. - № 9. - С. 132-138} утверждают, что автоматное программирование способно сыграть роль легендарной серебряной пули


Автоматное программирование, по сравнению с другими распространенными подходами к 
разработке сложных программных систем имеет много недостатков \nameref{kuznetcov_about}, 
но также и ряд преимуществ которые будут освещены далле в этом курсе.

Подход к разработке сложных программных систем был построен на основе подхода А. А. Шалыто\cite{Shalito:AutomataProgramming} и 
состоит из следующих этапов:
\begin{enumerate}
  \item Создание схемы связей блока управления с объектом управления и системой верхнего уровня.
  \item Разработка перечня и описания входных и выходных переменных.
  \item Получение алгоритма работы исходя из поставленной задачи.
  \item Эвристическое проектирование системы графов переходов конечных автоматов.
  \item Описание модели Promela.
  \item Верификация модели (с дополнительной проверкой LTL* соотвествия спецификации).
  \item Описание проекта, кодирование при помощи языка Си.
  \item Написание тестов (эмуляторов устройств) проверки работоспособности периферийных модулей системы.
\end{enumerate}

Существуют также языки автоматного программирования, результатом работы которых является программный 
код на различных языках, например \texttt{FSML}\cite{Lagunov:FSML}.

\chapter*{Описание объекта управления}
\addcontentsline{toc}{chapter}{Описание объекта управления}

Детальное описание объекта, проработка функций и требований как никак лучше может охарактеризовать автоматный подход к разработке, целью которого служит точное понимание системы еще на этапе проектирования.

\section*{Функциональные требования}
\addcontentsline{toc}{section}{Функциональные требования}



\section*{Диаграма состояний}
\addcontentsline{toc}{section}{Диаграма состояний}

Диаграмма состояний -- это, по существу, диаграмма состояний из теории автоматов со стандартизированными условными обозначениями\footnote{OMG. OMG Unified Modeling Language (OMG UML), Infrastructure Version 2.2 (February 2009)} \footnote{D. Drusinsky, Modelling and verification using UML statecharts, Elsevier, 2006}, которая может определять множество систем от компьютерных программ до бизнес-процессов. Используются следующие условные обозначения:
\begin{itemize}
  \item Круг, обозначающий начальное состояние.
  \item Окружность с маленьким кругом внутри(известная как <<кошачий глаз>>), обозначающая конечное состояние (если есть).
  \item Скруглённый прямоугольник, обозначающий состояние. Верхушка прямоугольника содержит название состояния. В середине может быть горизонтальная линия, под которой записываются активности, происходящие в данном состоянии.
  \item Стрелка, обозначающая переход. Название события (если есть), вызывающего переход, отмечается рядом со стрелкой. Охраняющее выражение может быть добавлено перед "/" и заключено в квадратные скобки (название\_события[охраняющее\_выражение]), что значит, что это выражение должно быть истинным, чтобы переход имел место. Если при переходе производится какое-то действие, то оно добавляется после "/" (название\_события[охраняющее\_выражение] / действие).
  \item Толстая горизонтальная линия с либо множеством входящих линий и одной выходящей, либо одной входящей линией и множеством выходящих. Это обозначает объединение и разветвление соответственно.
\end{itemize}

\section*{Таблица состояний}
\addcontentsline{toc}{section}{Таблица состояний}

\section*{Блок-схема}
\addcontentsline{toc}{section}{Блок-схема}

\section*{Функциональная схема}
\addcontentsline{toc}{section}{Функциональная схема}

При описании сложной системы управления ее разделяют на подсистемы, модули. Нрафическое представление взаимодействия компонент системы пожно представить при помощи функциональной схемы.

%-------------------------------------------------------------------------------
\chapter*{Верификация программ методом \texttt{Model Checking}}
\addcontentsline{toc}{chapter}{Верификация программ методом \texttt{Model Checking}}

\epigraph{Тестирование программы может весьма эффективно продемонстрировать наличие ошибок, но безнадежно неадекватно для демонстрации их отсутствия}{Эдсгер Вибе Дейкста}


\texttt{Model Checking\cite{Shalito:ModelChecking}} - это автоматизированный подход, позволяющий для заданной модели поведения 
системы с конечным (возможно, очень большим) числом состояний и логического свойства 
(требования) проверить, выполняется ли это свойство в рассматриваемых состояниях данной модели.
Алгоритмы для \texttt{Model Checking} обычно базируются на полном переборе пространства состояний модели. 
При этом для каждого состояния проверяется, удовлетворяет ли оно сформулированным требованиям. 
Алгоритмы гарантированно завершаются, так как модель программы конечна.

\newpage
\section*{Системы переходов\cite{Mironov:ModelChecking}}
\addcontentsline{toc}{section}{Системы переходов}\label{system_SEQUENCE}

\subsection*{Понятие системы переходов}
\addcontentsline{toc}{subsection}{Понятие системы переходов}\label{system_sequence_BASE}
\textbf{Системой переходов(СП)} называется пятерка $S$ вида
\begin{equation}\label{formula:1}
S = (P, Q, \delta, L, Q^0)
\end{equation}
компоненты которой имеют следующий смысл.
\begin{enumerate}
  \item $P$ - множество, элементы которого называются \textbf{утверждениями}
  \item $Q$ - множество, элементы которого называются \textbf{состояниями СП} $S$
  \item $\delta$ - ьинарное отношение на $Q$(т.е. $\delta \supseteq Q \times Q$) называемое 
        \textbf{отношением перехода}
  \item $L$ - функция вида
        \begin{equation}
		  L : Q \times P \to \{0, 1\}
		\end{equation}
		называемая \textbf{оценкой}, которая имеет следующий смысл: для каждого $q \in Q$ и 
		каждого $\rho \in P$ утверждение $\rho$ считается
		\begin{itemize}
		  \item \textbf{истинным} в состоянии $q$, если $L(q,\rho) = 1$, 
		  \item \textbf{ложным} в состоянии $q$, если $L(q,\rho) = 0$
		\end{itemize}
		выражение $L(q,\rho)$ может записываться более компактно в виде знакосочетания $p(\rho)$
  \item $Q^0 \in Q$ - множество \textbf{начальных состояний}   
\end{enumerate}

\section*{Темпоральная логика}\label{temporal_LOGIC}
\addcontentsline{toc}{section}{Темпоральная логика}\lhead{Темпоральная логика}

Одним из языков, на котором можно специфицировать свойства
систем, является темпоральная логика\cite{Mironov:ModelChecking}.
Свойства систем описываются в темпоральной логике при помощи темпоральных формул 
(которые мы будем называть также просто формулами). Примеры свойств, которые могут 
описываться в темпоральной логике:
\begin{enumerate}
  \item система при любом варианте своего функционирования не будет находиться ни в одном из состояний из заданного класса
  \item система при некотором функционировании когда-нибудь попадёт в некоторое состояние из заданного класса
\end{enumerate}
Как правило, при проведении рассуждений о темпоральных формулах рассматриваются не все возможные 
формулы, а только формулы из некоторого ограниченного класса. Классы темпоральных формул принято 
называть темпоральными логиками, или просто логиками, т.е. словосочетание <<темпоральная логика>> имеет два значения:
\begin{itemize}
  \item в первом значении – это язык, на котором можно выражать спецификации,
  \item а во втором – некоторый класс темпоральных формул.
\end{itemize}
Наиболее известны темпоральные логики
\begin{itemize}
  \item \nameref{temporal_logic_CTL} (\texttt{Computational Tree Logic}), и
  \item \nameref{temporal_logic_LTL} (\texttt{Linear Temporal Logic}).
\end{itemize}
Во всех темпоральных формулах основными структурными элементами являются утверждения. 
Утверждения имеют тот же смысл, что и в системах переходов, т.е. для каждого состояния 
$q$ каждой СП(\nameref{system_sequence_BASE}) и каждого утверждения $p$ определено значение $q(p) \in \{0, 1\}$. 
Совокупность всех утверждений обозначается символом $\rho$. Каждая темпоральная логика $\Phi$ 
должна удовлетворять следующим условиям.
\begin{enumerate}
  \item $P \supseteq \Phi$.
  \item Символы $1$ и $0$ принадлежат $\Phi$.
  \item Если $\psi$, $\eta \in \Phi$, то знакосочетания 
    \begin{equation}\label{formula:2}
      \neg\psi, \psi \wedge \eta, \psi \vee \eta
    \end{equation}
    тоже принадлежат логике $\Phi$.
\end{enumerate}
Формулы (\ref{formula:2}) называются булевыми комбинациями формул $\psi$ и $\eta$.

\subsection*{LTL}\label{temporal_logic_LTL}
\addcontentsline{toc}{subsection}{LTL}\lhead{LTL}

\subsection*{CTL}\label{temporal_logic_CTL}
\addcontentsline{toc}{subsection}{CTL}\lhead{CTL}

\section*{Язык Promela}\label{promela_LANGUAGE}
\addcontentsline{toc}{section}{Язык Promela}\lhead{Язык Promela}
\texttt{PROMELA (Process or Protocol Meta Language)} -- это язык описания описания моделей верификации,
созданный \texttt{Gerard J. Holzmann}\cite{Promela:Wiki}. Язык поддерживает создание процессов
для проверки распределенных моделей. Модели в языке могут взаимодействовать между собой при помощи
каналов сообщений как в синхронном 2режиме, так и в асинхронном. Модели описанные при помощи языка
могут быть обработаны и проанализированы \nameref{spin_MC} о чем будет рассказано в последующих главах.
Существуют иные реализации и утилиты использующие язык \texttt{Promela}, но пока они рассматриваться не будут.

В основном, язык предназначен для проверки логики работы парраллельных систем. Модели описанные
\texttt{Promela} и обработанные утилитой \texttt{SPAN} проверяют модель на корректность в режиме случайной
или последовательной симуляции или генерируют код на \texttt{C} для быстрой и полной проверки в системном окружении.
В процессе симуляции и проверки \texttt{SPIN} проверяет отсутствия \texttt{deadlocks}\footnote{\url{https://ru.wikipedia.org/wiki/Deadlock}},
неопределенных состояний и неиспользуемых частей кода. Также данный подход может проверять правильность системных инвариантов\footnote{\url{https://en.wikipedia.org/wiki/Invariant_(computer_science)}},
а также поиска зацикливаний и неправильных ветвлений. Также он поддерживает проверку \texttt{LTL} ограничений.

Список спецификаций различных систем, модель которых описана на языке \texttt{Promela}
приведена в статье \texttt{Alberto Lluch}\footnote{\url{http://www.albertolluch.com/research/promelamodels}}
\subsection*{Типы данных}\label{promela_language_DATATYPES}
\addcontentsline{toc}{subsection}{Типы данных}

\begin{tabular}{l|l|l|l}
  \hline
  Имя   & Рамер(в битах) & Тип & Диапазон значений \\ \hline
  bit   & 1 & unsigned & 0..1 \\ \hline
  bool  & 1 & unsigned & 0..1 \\ \hline
  byte  & 8 & unsigned & 0..255 \\ \hline
  mtype & 8 & unsigned & 0..255 \\ \hline
  short & 16 & signed & $-2^15$..$2^15 - 1$ \\ \hline
  int   & 32 & signed & $-2^31$..$2^31 - 1$ \\ \hline
  \hline
\end{tabular}

Типы \texttt{bit} и \texttt{bool} это синонимы.

Также, переменные, могут быть представлены в виде массива. Пример определения:
\begin{alltt}
\cname{int} x [10];
\end{alltt}
в данном примере определен массив из 10 элементов типа \texttt{int} с именем \texttt{x}

Доступ к элементам массива осуществляется по индексам, в свою очередь индекс не может
превышать размерность массива.

Имена переменных и процессов не должно совпадать с ключевыми словами языка \nameref{promela_language_KEYWORDS}

\subsection*{Процессы}\label{promela_language_PROCESS}
\addcontentsline{toc}{subsection}{Процессы}

Значения переменных или состояние каналов сообщений могут быть изменены только внутри процесса.
Поведение процесса описывается декларацией \texttt{proctype}. В примере ниже мы определяем процесс
\texttt{A} с одной переменной \texttt{state}
\begin{alltt}
\cname{proctype} A() \{
  \cname{byte} state;
  state = 3;
\}
\end{alltt}
\texttt{proctype} только определяет процесс, но не запускает его. При инициализации модели
запускается только один процесс с именем \texttt{init} который должен быть явным образом задан в
каждом \texttt{Pamela} описании.

Процесс может быть запущен при помощи оператора \texttt{run}, который в качестве апгумента принимает
имя запускаемого процесса, заданного декларацией \texttt{proctype}. Оператор запуска может быть использован в
определении процесса, а не только в процессе инициализации \texttt{init}, он предназначен для динасического
запуска процессов.

Процесс завершает свою работу при достижении окончания определения в блоке \texttt{proctype}, а также завершает
все дочерние(созданные завершаемым проуессом) процессы.

Перед декларации \texttt{proctype} может стоять квалификатор \texttt{active} который сигнализирует
об автоматическом запуске процесса. В свою очередь у \texttt{active} можно указать квантификатор,
который будет задавать количество запускаемых процессов.

\begin{alltt}
\cname{active} \cname{proctype} A() \{ ... \}
\cname{active} [4] \cname{proctype} B() \{ ... \}
\end{alltt}
в примере выше описан автоматический запуск двух экземпляров процесса \texttt{B}
и автоматический запуск процесса \texttt{A}

\subsection*{Атомарные конструкции}\label{promela_language_ATOMIC}
\addcontentsline{toc}{subsection}{Атомарные конструкции}

Последовательность выражений можно обернуть фигурными скобками с ключевым словом \texttt{atomic},
тем самым обозначить исполнение последовательности одним единым блоком без разделения другими процессами.

\begin{alltt}
\cname{atomic} \{
  ...
\}
\end{alltt}


\subsection*{Каналы сообщений}\label{promela_language_CHAN}
\addcontentsline{toc}{subsection}{Каналы сообщений}

Каналы сообщений необходимы для осуществления межпроцессного взаимодействия.
Соответсвенно, каналы могут быть глобальными и локальными. Например:

\begin{alltt}
\cname{chan} qname = [16] \cname{of} \cname{\{short\}}
\end{alltt}

в примере мы определили буферный канал сообщений размерностью 16 смообщений типа
\texttt{short}. Выражение

\begin{alltt}
qname ! expression;
\end{alltt}

помещает(посылает) значение заданное выражением \texttt{expression} в канал с именем
\texttt{qname}, оно будет помещено в коней очереди канала. Выражение:

\begin{alltt}
qname ? msg;
\end{alltt}

получает сообщение из начала очереди и помещает его в переменную \texttt{msg}.
Канал работает по механизму \texttt{FIFO}

Для того, чтобы определить канал сообщений без очереди, следует в качестве размера передать 0.
Пример:

\begin{alltt}
\cname{chan} port = [0] \cname{of} \cname{\{byte\}}
\end{alltt}

Подобного рода каналы работают в синхронном режиме, а именно получатель и отправитель ожидают
пока получатель или отправитель не завершаь операцию приема или передачи сообщения.

В случае, если канал сообщений будет заполнен(заполнена очередь), то канал себя ведет как синхронный
- блокирует операцию. Канал, в один момент времени может работать или на прием или на передачу.
Каналы не являются однонаправленными и их можно использовать соместно несколькими процессами
получателями и отправителями.

\subsection*{Ветвления и конструкции управления}\label{promela_language_IF}
\addcontentsline{toc}{subsection}{Ветвления и кнструкции управления}

Простейшее сравнение двух переменных:

\begin{alltt}
\cname{if}
:: ( a != b ) -> option1
:: ( a == b ) -> option2
\cname{fi}
\end{alltt}

в примере имеется две исполняемые последрвательности, каждая описывается
двойным двоеточим \texttt{::}. Только одна последовательность будет исполнена
в блоке. Последовательность может быть выбрана только если будет
исполнено первое выражение. Первое вырадение называется защитным.

В примере выше, мы имеем взаимоисключающие выражения - их не должно быть.
Если более чем одно из защитных выражений исполнимо, одно из описанных последовательностей
будет выбрано. Если все выражения не исполнимы, процесс блокируется, пока хоть одно из них не будет исполнимо

\begin{alltt}
\cname{if}
:: (A == \cname{true}) -> option1;
:: (B == \cname{true}) -> option2; /* May arrive here also if A==true */
:: \cname{else} -> fallthrough_option;
\cname{fi}
\end{alltt}
The consequence of the non-deterministic choice is that, in the example above, if A is true,
both choices may be taken. In "traditional" programming, one would understand an
if - if - else structure sequentially. Here, the if - double colon - double colon must be
understood as "any one being ready" and if none is ready, only then would the else be taken.
\begin{alltt}
\cname{if}
:: value = 3;
:: value = 4;
\cname{fi}
\end{alltt}
In the example above, value is non-deterministically given the value 3 or 4.

There are two pseudo-statements that can be used as guards: the timeout statement
and the else statement. The timeout statement models a special condition that allows
a process to abort the waiting for a condition that may never become true. The else
statement can be used as the initial statement of the last option sequence in a selection
or iteration statement. The else is only executable if all other options in the same
 selection are not executable. Also, the else may not be used together with channels.

\subsection*{Циклы}\label{promela_language_LOOP}
\addcontentsline{toc}{subsection}{Циклы}

Для повторения группы выражений применяются циклы. Пример
\begin{alltt}
\cname{do}
  :: count = count + 1
  :: a = b + 2
  :: (count == 0) -> \cname{break}
\cname{od}
\end{alltt}
Только одна последовательность может быть исполнена в единицу времени. После
завершения исполнения последовательности исполнение повторяется. Нормальное
завершения цикла \texttt{break} выражение, тем самым передает управление следующей
инструкции после блока цикла.

\subsection*{Безусловные переходы}\label{promela_language_GOTO}
\addcontentsline{toc}{subsection}{Безусловные переходы}

Другой путь выхода из цикла - \texttt{goto} выражение. Для примера перепишем пример выше
\begin{alltt}
\cname{do}
  :: count = count + 1
  :: a = b + 2
  :: (count == 0) -> \cname{goto} done
\cname{od}
done:
  \cname{skip};
\end{alltt}
Переход будет осуществлен на метку с именем done сразу после цикла. Сама метка
может быть записана только перед выражением. \texttt{skip} это пустая инструкция которая
не предпринимает никаких действий.


\subsection*{Проверки}\label{promela_language_ASSERT}
\addcontentsline{toc}{subsection}{Проверки}

Выжной частью модели описанной языком \texttt{Promela} является утверждение
\begin{alltt}
\cname{assert}(any_boolean_condition)
\end{alltt}
выражение всегда исполняется. Если логическое условие верно - то ничего не
происходит, иначе - будет воспроизведена ошибка в просессе верификации
 при помощи \nameref{spin_MC}

\subsection*{Составные типы данных}\label{promela_language_STRUCT}
\addcontentsline{toc}{subsection}{Составные типы данных}

При помощи определение \texttt{typedef} в языке, можно задать составной тип данных,
который будет использоваться по заданному ему имени в любой части модели.
\begin{alltt}
\cname{typedef} MyStruct \{
    \cname{short} Field1;
    \cname{byte}  Field2;
\};
\end{alltt}
Для доступа к полям составного типа данных осуществляется также как и в языке
\texttt{C} посредствам вызова знака \texttt{.}. Пример:
\begin{alltt}
MyStruct x;
x.Field1 = 1;
\end{alltt}
в примере, значение поля \texttt{Field1} переменной \texttt{x} устанавливается
значение 1.

\subsection*{Исполоняемость}\label{promela_language_EXECUTABILITY}
\addcontentsline{toc}{subsection}{Исполняемость}

Исполняемость модели обеспечивает базовые средства языка для моделирования
синхронизации процессов.

\begin{alltt}
\cname{mtype} = {M_UP, M_DW};
\cname{chan} Chan_data_down = [0] \cname{of} \{\cname{mtype}\};
\cname{chan} Chan_data_up   = [0] \cname{of} \{\cname{mtype}\};
\cname{proctype} P1 (\cname{chan} Chan_data_in, Chan_data_out) \{
    \cname{do}
    ::  Chan_data_in  ? M_UP -> \cname{skip};
    ::  Chan_data_out ! M_DW -> \cname{skip};
    \cname{od};
\};

\cname{proctype} P2 (\cname{chan} Chan_data_in, Chan_data_out) \{
    \cname{do}
    ::  Chan_data_in  ? M_DW -> \cname{skip};
    ::  Chan_data_out ! M_UP -> \cname{skip};
    \cname{od};
\};

\cname{init} \{
    \cname{atomic} \{
        \cname{run} P1 (Chan_data_up,   Chan_data_down);
        \cname{run} P2 (Chan_data_down, Chan_data_up);
    \}
\}
\end{alltt}
В примере два процесса \texttt{P1} и \texttt{P2} имеют недетерминированный выбор 1 входа во 2 выход.
Возможны два варианта выбора из которых только один будет выбран.
Повторение будет бесконечным. При этом модель не получит \texttt{deadlock}\footnote{\url{https://ru.wikipedia.org/wiki/Deadlock}}

Когда \nameref{spin_MC} анализирует модель он проверяет ее при помощи недетерминированного
алгоритма и проверит все возможные ее состояния. Когда симулятор \nameref{spin_MC} будет
визуализировать возможные не проверенные связи, он будет использовать генератор
случайных чисел, для проверки недетерминированный состояний.
Следовательно симулятор может не показать плохие пути выполнения
(хотя таких путей в примере нет). Это иллюстрирует разницу между проверкой и симуляцией.
Также можно генерировать исполняемый код из моделей \texttt{Promela} с использованием \texttt{Refinement}\footnote{
 Sharma, Asankhaya. A Refinement Calculus for Promela. 2013 18th International Conference on Engineering of Complex Computer Systems, 2013. doi:10.1109/ICECCS.2013.20 \\
 ссылка на реализацию: \url{https://github.com/codelion/SpinR.git}
}


\subsection*{Ключевые слова}\label{promela_language_KEYWORDS}
\addcontentsline{toc}{subsection}{Ключевые слова}

Список ключевых слов используемых в языке

\begin{alltt}
\cname{active}
\cname{assert}
\cname{atomic}
\cname{bit}
\cname{bool}
\cname{break}
\cname{byte}
\cname{chan}
\cname{d_step}
\cname{D_proctype}
\cname{do}
\cname{else}
\cname{empty}
\cname{enabled}
\cname{fi}
\cname{full}
\cname{goto}
\cname{hidden}
\cname{if}
\cname{inline}
\cname{init}
\cname{int}
\cname{len}
\cname{mtype}
\cname{empty}
\cname{never}
\cname{nfull}
\cname{od}
\cname{of}
\cname{pc_value}
\cname{printf}
\cname{priority}
\cname{prototype}
\cname{provided}
\cname{run}
\cname{short}
\cname{skip}
\cname{timeout}
\cname{typedef}
\cname{unless}
\cname{unsigned}
\cname{xr}
\cname{xs}
\end{alltt}

Полное описание языка в форме Бэкуса-Наура представленя в приложении \nameref{promela_BNF}

\newpage
\section*{SPIN}\label{spin_MC}
\addcontentsline{toc}{section}{SPIN}
\lhead{SPIN}

\texttt{SPIN} (англ. \texttt{Simple Promela Interpreter})\footnote{\url{https://en.wikipedia.org/wiki/SPIN_model_checker}} -
утилита для верификации корректности распределенных программных моделей.
Служит для автоматизированной проверки моделей. Развивается \texttt{Gerard J. Holzmann} и
его коллегами из \texttt{Unix group} центра \texttt{Computing Sciences Research Center} в
\texttt{Bell Labs} начиная с 1980 года. С 1991 года программа распространяется
бесплатно вместе с исходными кодами.

В отличие от многих программ для проверки моделей, \texttt{SPIN} не выполняет
работу сам, а генерирует программу на языке Си, которая решает конкретную задачу.
За счет этого достигается экономия памяти и повышение производительности, и становится
возможным использовать фрагменты кода на языке Си непосредственно из модели.
\texttt{SPIN} предоставляет множество опций для ускорения проверки моделей.

Описание опций можно посмотреть в приложении \nameref{spin_quick_REFERENCE}

%-------------------------------------------------------------------------------
\newpage
\chapter*{Автоматное программирование}
\addcontentsline{toc}{chapter}{Автоматное программирование}

Автоматное программирование \cite{Karpov:AutomataLanguage} - это некая общая парадигма программирования, суть которой заключается в том, 
что создаваемая программа рассматривается как реализация некоторого управляющего автомата.

В традиционном программировании в последнее время все шире используется понятие <<событие>>, 
тогда как предлагаемый стиль программирования базируется на понятии <<состояние>>. Понятия 
<<состояние>> и <<входное воздействие>>, которое может быть входной переменной или событием, 
в совокупности образуют <<автомат без выхода>>. Добавляя к ним еще понятие <<выходноговоздействия>>, 
получаем <<автомат>> (конечный, детерминированный)\cite{Shalito:AutomataProgramming2}.

Особенность этого подхода состоит в том, что при его использовании автоматы задаются графами переходов. 
Для различения однотипных вершин вводится понятие <<кодирование состояний>>. При выборе <<многозначного кодирования>> 
с помощью одной переменной можно различить состояния, число которых совпадает с числом возможных значений 
выбранной переменной. Это позволило ввести в программирование понятия <<наблюдаемость>> и <<управляемость>> 
программ, широко используемые в теории управления.

В рамках предлагаемого подхода программирование выполняется <<через состояния>>, а не <<через переменные>> (флаги), 
что позволяет лучше понять и специфицировать задачу и ее составные части. При этом необходимо отметить, 
что в автоматно-ориентированном программировании проектирование, реализация и отладка проводятся в 
терминах автоматов. Благодаря этому в рамках предлагаемого подхода от графа переходов к тексту 
программы можно переходить формально и изоморфно.

%-------------------------------------------------------------------------------
\newpage
\chapter*{Тестирование}
\addcontentsline{toc}{chapter}{Тестирование}

\epigraph{Если отладка - процесс удаления ошибок, то программирование должно быть процессом их внесения}{Эдсгер Вибе Дейкста}

\section*{Модульное тестирование\footnote{В подготовке данной части материала использовалась статья \texttt{Google testing framework (gtest)}\url{https://habrahabr.ru/post/119090/}}}
\addcontentsline{toc}{section}{Модульное тестирование}

Модульное тестирование, или юнит-тестирование (англ. \texttt{unit testing})\footnote{\url{ https://en.wikipedia.org/wiki/Unit_testing}} - процесс в программировании, 
позволяющий проверить на корректность отдельные модули исходного кода программы.

Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, 
не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и 
устранение таких ошибок.

Цель модульного тестирования - изолировать отдельные части программы и показать, что по отдельности эти части работоспособны.


Существует множество библиотек способствующих к быстрому написанию тестов для языка Си. Мы будем использовать \texttt{GoogleTest}\footnote{\url{ https://github.com/google/googletest.git}}.


\subsection*{Ключевые понятия}
\addcontentsline{toc}{subsection}{Ключевые понятия}

Ключевым понятием в \texttt{Google test framework} является понятие утверждения (\texttt{assert}). Утверждение представляет собой выражение, результатом выполнения 
которого может быть успех (\texttt{success}), некритический отказ (\texttt{nonfatal failure}) и критический отказ (\texttt{fatal failure}). Критический отказ вызывает 
завершение выполнения теста, в остальных случаях тест продолжается. Сам тест представляет собой набор утверждений. Кроме того, тесты могут быть сгруппированы в 
наборы (\texttt{test case}). Если сложно настраиваемая группа объектов должна быть использована в различных тестах, можно использовать фиксации 
(\texttt{fixture}). Объединенные наборы тестов являются тестовой программой (\texttt{test program}).

\subsection*{Утверждения (\texttt{assertion})}
\addcontentsline{toc}{subsection}{Утверждения (\texttt{assertion})}

Утверждения, порождающие в случае их ложности критические отказы начинаются с \texttt{ASSERT\_}, некритические - \texttt{EXPECT\_}. Следует иметь ввиду, что в случае 
критического отказа выполняется немедленный возврат из функции, в которой встретилось вызвавшее отказ утверждение. Если за этим утверждением идет какой-то 
очищающий память код или какие-то другие завершающие процедуры, можете получить утечку памяти.

Имеются следующие утверждения (некритические начинаются не с \texttt{ASSERT\_}, а с \texttt{EXPECT\_}):

\begin{itemize}
  \item Простейшие логические
        \begin{verbatim}
          ASSERT_TRUE(condition);
          ASSERT_FALSE(condition);
        \end{verbatim}

  \item Сравнение
        \begin{verbatim}
          ASSERT_EQ(expected, actual); - =
          ASSERT_NE(val1, val2); - !=
          ASSERT_LT(val1, val2); - <
          ASSERT_LE(val1, val2); - <=
          ASSERT_GT(val1, val2); - >
          ASSERT_GE(val1, val2); - >=
        \end{verbatim}

  \item Сравнение строк
        \begin{verbatim}
          ASSERT_STREQ(expected_str, actual_str);
          ASSERT_STRNE(str1, str2);
          ASSERT_STRCASEEQ(expected_str, actual_str); - регистронезависимо
          ASSERT_STRCASENE(str1, str2); - регистронезависимо
        \end{verbatim}

  \item Проверка на исключения
        \begin{verbatim}
          ASSERT_THROW(statement, exception_type);
          ASSERT_ANY_THROW(statement);
          ASSERT_NO_THROW(statement);
        \end{verbatim}

  \item Проверка предикатов
        \begin{verbatim}
          ASSERT_PREDN(pred, val1, val2, ..., valN); - N <= 5
          ASSERT_PRED_FORMATN(pred_format, val1, val2, ..., valN); - работает аналогично предыдущей, но позволяет контролировать вывод
        \end{verbatim}

  \item Сравнение чисел с плавающей точкой
        \begin{verbatim}
          ASSERT_FLOAT_EQ(expected, actual); - неточное сравнение float
          ASSERT_DOUBLE_EQ(expected, actual); - неточное сравнение double
          ASSERT_NEAR(val1, val2, abs_error); - разница между val1 и val2 не превышает погрешность abs_error
        \end{verbatim}

  \item Вызов отказа или успеха
        \begin{verbatim}
          SUCCEED();
          FAIL();
          ADD_FAILURE();
          ADD_FAILURE_AT("file_path", line_number);
        \end{verbatim}
\end{itemize}

\subsection*{Запуск тестов}
\addcontentsline{toc}{subsection}{Запуск тестов}

Объявив все необходимые тесты, мы можем запустить их с помощью функции \texttt{RUN\_ALL\_TESTS()}. Функцию можно вызывать только один раз. Желательно, чтобы тестовая программа возвращала 
результат работы функции \texttt{RUN\_ALL\_TESTS()}, так как некоторые автоматические средства тестирования определяют результат выполнения тестовой программы по тому, что она возвращает.

\subsection*{Фалаги}
\addcontentsline{toc}{subsection}{Флаги}


Вызванная перед \texttt{RUN\_ALL\_TESTS()} функция \texttt{InitGoogleTest(argc, argv)} делает вашу тестовую программу не просто исполняемым файлом, выводящим на экран результаты тестирования. 
Это целостное приложение, принимающие на вход параметры, меняющие его поведение. Как обычно ключи \texttt{-h}, \texttt{--help} дадут вам список всех поддерживаемых параметров. Перечислю некоторые 
из них (за полным списком можно обратиться к документации).
\begin{verbatim}
./test --gtest_filter=TestCaseName.*-TestCaseName.SomeTest - запустить все тесты набора TestCaseName за исключением SomeTest
./test --gtest_repeat=1000 --gtest_break_on_failure - запустить тестирующую программу 1000 раз и остановиться при первой неудаче
./test --gtest_output="xml:out.xml" - помимо выдачи в std::out будет создан out.xml - XML отчет с результатами выполнения тестовой программы
./test --gtest_shuffle - запускать тесты в случайном порядке
\end{verbatim}

Если вы используете какие-то параметры постоянно, можете задать соответствующую переменную окружения и запускать исполняемый файл без параметров. 
Например задание переменной \texttt{GTEST\_ALSO\_RUN\_DISABLED\_TESTS} ненулевого значения эквивалентно использованию флага \texttt{--gtest\_also\_run\_disabled\_tests}.

\section*{Интеграционное тестирование}
\addcontentsline{toc}{section}{Интеграционное тестирование}

\section*{Эмуляция устройств}
\addcontentsline{toc}{section}{Эмуляция устройств}

%-------------------------------------------------------------------------------
\newpage
\chapter*{Описание проекта}
\addcontentsline{toc}{chapter}{Описание проекта}

\section*{\texttt{CMake}}
\addcontentsline{toc}{section}{\texttt{CMake}}

\texttt{CMake} (от англ. \texttt{cross platform make})\footnote{\url{ https://en.wikipedia.org/wiki/CMake}} - это кроссплатформенная система автоматизации 
сборки программного обеспечения из исходного кода. CMake не занимается непосредственно сборкой, a лишь генерирует файлы управления 
сборкой из файлов \texttt{CMakeLists.txt}:
\begin{enumerate}
	\item \nameref{Makefile} в системах \texttt{Unix} для сборки с помощью \texttt{make};
	\item файлы \texttt{projects/solutions} (\texttt{.vcxproj/.vcproj/.sln}) в \texttt{Windows} для сборки с помощью \texttt{Visual C++};
	\item проекты \texttt{XCode} в \texttt{Mac OS X}
\end{enumerate}

Наиболее полную информацию по использованию \texttt{CMake} можно найти на официальном сайте \url{ https://cmake.org/documentation/}


%Структура проекта

%project->src
%project->3rdparty/googletest
%project->tests
%project->tests_data
%project->models

%CMakeLists.txt

%cmake_minimum_required (VERSION 2.6)
%project (Tutorial)

%Подпроект

%Библиотеки

%Makefile

%Сборка

\section*{\texttt{Makefile}}\label{Makefile}
\addcontentsline{toc}{section}{\texttt{Makefile}}

%-------------------------------------------------------------------------------
\newpage
\chapter*{Практические работы}\label{practical_works}
\addcontentsline{toc}{chapter}{Практические работы}
\lhead{Практические работы}

Каждая практическая работа расчитана на 1-3 практических занятия и соотвествует лабораторным работам.
%-------------------------------------------------------------------------------
\section*{Описание объекта управления}\label{practical_work_1}
\addcontentsline{toc}{section}{Описание объекта управления}
\lhead{Описание объекта управления}

Попробуем описать объект управления - "кондиционер". Довольно таки распространенное в бытовом плане успройство, к тому же
интуитивно понятно как оно работает. Поэтому не сложно быдет выделить основные состояния в которых может находится кондиционер.

Первое с чего можно начать - это включение устройства. Поэтому первичное состояние кондиционера - выключено. Далее мы нажимаем
кнопку на пульте управления(обработка сигналов с пульта управления это немного более сложный процесс и для простоты мы будем 
рассматривать пульт управления как некое абстрактное устройство которое может менять состояние нашего объекта с включенного на 
выключенный и наоборот) либо на самом кондиционере. После включения питания кондиционер восстанавливает параметры(параметры 
установленные до выключения питания) и переходит в состояние "Управление". Какие параметры могут быть у нашего кондиционера:
  \begin{enumerate}
    \item $T$ - температура которую необходимо поддерживать кондиционеру
    \item $W_1$ - Минимальное время нагрева до проверки температуры
    \item $W_2$ - Минимальное хлаждения до проверки температуры
    \item $W_3$ - Минимальное время ожидания до проверки  температуры
  \end{enumerate} 
сразу хочется оговориться, что для простоты работы и понимания функциональные требования к кондиционеру были сокращены до минимальных, а именно до
поддержания установленной температуры окружающей среды помещения в актуальном состоянии. 

Как видим параметров у нашего объекта не много, при этом параметры $W_1, W_2, W_3$ являются сервисными параметрами и их пользователи изменять 
не могут, но они являются важными для описания, поэтому были перечислены.

После восстановления параметров и перехода в состояние "Управление" объект управления должен получить(измерить) температуру окружающей среды
и в зависимости от результат сравнения полученного значения температуры $t$ с температурой которую надо поддерживать $T$ перейти в 
соответствующее состояние:
  \begin{enumerate}
    \item $t < T$  - температура окружающей среды меньше поддерживаемой температуры, поэтому следует перейти в состояние "Нагрев"
    \item $t > T$  - температура окружающей среды больше поддерживаемой температуры, поэтому следует перейти в состояние "Охлаждение"
    \item $t == T$ - температура окружающей среды соответствует поддерживаемой температуры, поэтому следует перейти в состояние "Ожидание"
  \end{enumerate} 
перейдя в нужное состояние кондиционер либо поизведет действия по охлаждению, либо по нагреву, либо ничего делать не будет
(будет экономить электроэнергию, также называемый "Режим ожидания"). Из любого из этих состояний объект управления переходит в состояние "Управления" 
по условию:
  \begin{enumerate}
    \item $w > W_1$  - внутренний счетчик времени работы в состоянии "Нагрев" больше предельного значения
    \item $w > W_2$  - внутренний счетчик времени работы в состоянии "Охлаждение" больше предельного значения
    \item $w > W_3$  - внутренний счетчик времени работы в состоянии "Ожидание" больше предельного значения
  \end{enumerate} 
при этом, при вхождении в состояние внутренние счетчики сбрасываются.

После нажания кнопки выключения на пульте управления либо на самом устройстве, объект управления переходит из состояния "Управление" 
в состояние "Выключен". Перед выключением мы сохраняем параметры. Как видите, мы можем перейти в состояние "Выключен", только из состояния 
"Управления", что накладывает некоторые ограничения на нашу модель, а именно ожиданиt перехода в состояние "Управление". Наша модель
не является критичной ко времени срабатывания(если бы мы упраляли задвижками ТВЭЛ(тепловыделяющий элемент) в АЭС мы бы в первую очередь 
задумались о реакции системы) поэтому мы упростили ее.


При помощи \texttt{PlantUML}\footnote{\url{https://en.wikipedia.org/wiki/PlantUML}} постоим диаграмму состояний.

Для описания диаграммы перейдем на сайт \texttt{PlantUML}\url{http://www.plantuml.com/plantuml/uml} и 
наберем следующую последовательность символов(если не хочеться вводить, можно перейти по \href{http://www.plantuml.com/plantuml/uml/bPHBJW9148RtVOeA2nScB80T0S8XI5Ye2nC69E5Xi0aR5ZoYn9XeeXit4XyN6951G1vNgBwHVpV8JB25E9FCCDFr_VLtrHJf2tbQa_LoISYYB3aKucTs-PqNgiCkyPGNFESXZzKLZyrlJxNO3GbHSWfE9IUQISA1A_TvYR0sw3b2FR8SJT4agU_4h-pn38IHKntLrNT2XgbggIwFyF9MNIDeGggDDO-7wiO8P5O23nhGgLGFLrVT4HpRD0Ev6txkALQrl4VyQVWU7bR6zSvv0YLlmsiu6rd3gqKN0XtIA7yOVmC_bvyn6xL12tN9NtWrGcLDLhZVuc9M3iGOZFkBqHJQGUkkYAF34mhdgerAE4NynajJh06IhZSP9xw7ZJREZf5R15U53I58GHRaYzx0kloxYHy7JtwLulW24fJP0_ItAwGjIqffC216uVhvdpji83mRIHp8OjcffOHDSpyVzNchuPAJbyPmi3KhiycaThkrGE5QiN0cToUDRPAAIbKwP12gvgqCxUubcKff3pCzO6Fhc62qZYksllw3ViGWpGmN62HRh4ZZ4yK_pZS0}{ссылке}):

\begin{alltt}
\cname{@startuml}
\cname{title} "Работа кондиционера"

\cname{legend}
|=    |= Описание                    |
| t   | Температура окружающей среды |
| T   | Граничная температура        |
| w   | Текущее значение таймера     |
| W1  | Таймаут нагрева              |
| W2  | Таймаут охлаждения           |
| W3  | Таймаут ожидания             |
\cname{end legend}

[*] \cname{-down->} Управление: Восстановление
Управление -> [*]: Сохранение
Управление \cname{-down->} Нагрев: t < T
Управление \cname{-down->} Охлаждение: t > T
Нагрев \cname{-up->} Управление: w > W1<&timer>
Охлаждение \cname{-up->} Управление: w > W2<&timer>
Управление \cname{-left->} Ожидание: t == T
Ожидание \cname{-right->} Управление: w > W3<&timer>

\cname{note right of} Управление : Восстановление режима и температуры {\textbackslash}nСохранение режима и температуры {\textbackslash}nИзменение температуры
\cname{@enduml}

\end{alltt}

После нажатия на клаыишу "\texttt{Submit}" мы получим следующую диаграму:

\begin{figure}
  \includegraphics[width=\textwidth]{cond_sample}
  \centering
    \caption{Диаграмам состояний работы кондиционера}
  \label{fig:cond_diagram}
\end{figure}

Давайте более детально рассмотрим текст описания диаграммы.
Ключевое слово \texttt{@startuml} начинает блок описания диаграмы, а \texttt{@enduml} завершает его. \texttt{title} задает наименование нашей диаграмы. 
\texttt{legend} начинает блок легенды диаграмы, а \texttt{end legend} завершает ее. Внутри легенды пиведена конструкция задания таблицы, в которой мы описываем 
необходимые нам параметры. Состояния начала и окончания задаются при помощи \texttt{[*]} последовательности. Стрелочки \texttt{-->} задают переходы 
между состояниями, а \texttt{:} задают условия переходов. \texttt{note right of} добавляет подсказку к состоянию.

Подробности использования языка \texttt{PlantUML} можно найти по ссылке \url{http://plantuml.com/PlantUML_Language_Reference_Guide.pdf}

\newpage
\section*{Модель \texttt{Promela}}\label{practical_work_2}
\addcontentsline{toc}{section}{Модель \texttt{Promela}}
\lhead{Модель \texttt{Promela}}

Описанный выше объект управления формализуем при помощи \nameref{promela_LANGUAGE}.

\begin{alltt}
\cname{mtype} = \{START, ON, OFF, CONTROL, COOLING, HEATING, WAITING\};

\cname{mtype} state = START;
\cname{int} guard\_temperature = 12;
\cname{int} current\_temperature = 0;
\cname{int} waiting\_count = 10;

\cname{proctype} conditioner() \{
  printf("[Conditioner \%d] Вход{\textbackslash}n", \_pid);
  \cname{do}
    :: (state == OFF) -> 
      printf("[Conditioner \%d] Сохраняем температуру и параметры{\textbackslash}n", \_pid);
      \cname{break};
    :: (state == ON) ->
      printf("[Conditioner \%d] Загрузка темепратуры и параметров{\textbackslash}n", \_pid);
      guard_temperature = 12;
      current_temperature = 14;
      printf("[Conditioner \%d] Loaded: \%dC, Current: \%dC{\textbackslash}n", 
             \_pid, guard\_temperature, current\_temperature);
      state = CONTROL;
    :: (state == CONTROL) ->
      printf("[Conditioner \%d] Управление{\textbackslash}n", \_pid);
      /** Получаем тепуратуру помещения */
      printf("[Conditioner \%d] Температура: \%dC{\textbackslash}n", 
             \_pid, current\_temperature);
      \cname{if}
        :: (current\_temperature > guard\_temperature) ->
          state = COOLING
        :: (current\_temperature < guard\_temperature) ->
          state = HEATING;
        :: \cname{else} ->
          state = WAITING; 
      \cname{fi}      
    :: (state == COOLING) ->
      \cname{assert}(current\_temperature > guard\_temperature);
      printf("[Conditioner \%d] Охлаждение{\textbackslash}n", \_pid);
      current\_temperature--;
      state = CONTROL;
    :: (state == HEATING) ->
      \cname{assert}(current\_temperature < guard\_temperature);
      printf("[Conditioner \%d] Нагрев{\textbackslash}n", \_pid);
      current\_temperature++;
      state = CONTROL;
    :: (state == WAITING) ->
      \cname{assert}(current\_temperature == guard\_temperature);
      printf("[Conditioner \%d] Ожидание{\textbackslash}n", \_pid);
      state = CONTROL;
      \cname{if}
        :: (waiting\_count == 5) ->
          printf("[Conditioner \%d] Эмуляция. Понидение температуры.{\textbackslash}n", \_pid);
          current\_temperature = guard\_temperature - 2;
          waiting\_count--;
        :: (waiting\_count < 0) ->
          state = OFF;
        :: \cname{else} ->
          waiting\_count--;
      \cname{fi}  
  \cname{od}
  printf("[Conditioner \%d] Выход{\textbackslash}n", \_pid);
\}


\cname{init} \{
  \cname{run} conditioner();
  \cname{assert}(state == START);
  printf("[Init] Запуск{\textbackslash}n");
  state = ON
\}

\end{alltt}

Определено 7 состояний:
\begin{enumerate}
  \item \texttt{START} - ?
  \item \texttt{ON} - Состояние включение объекта управления
  \item \texttt{OFF} - Состояние выключение объекта управления
  \item \texttt{CONTROL} - Состояние управления
  \item \texttt{COOLING} - Состояние нагрева
  \item \texttt{HEATING} - Состояние охлаждения
  \item \texttt{WAITING} - Состояние ожидания
\end{enumerate}

\newpage
\section*{Проект Си}\label{practical_work_3}
\addcontentsline{toc}{section}{Проект Си}\lhead{Проект Си}

\begin{lstlisting}[label={main_c_fsm}, caption={Пример управления состояниями на \texttt{C}}]
#include "conditioner.h"

int
business_fsm(enum State               state, 
             struct ConditionerInter *cond, 
             struct StorageInter     *storage) {
    int ret = 1;
    do {
        if (cond->is_running && !cond->is_running(state)) {
            state = _PowerOff;
        }
        switch (state) {
            case _PowerOff: {
                ret = storage->property_store();
                break;
            }
            case _PowerOn: {
                storage->property_load();
                state = _Control;
                break;
            }
            case _Waiting: {
                int wait = storage->property_get_int(WaitingIdle);
                cond->process_engine(Waiting, wait);
                state = _Control;
                break;
            }
            case _Heating: {
                int wait = storage->property_get_int(WaitingHeating);
                cond->process_engine(Heating, wait);
                state = _Control;
                break;
            }
            case _Cooling: {
                int wait = storage->property_get_int(WaitingCooling);
                cond->process_engine(Cooling, wait);
                state = _Control;
                break;
            }
            case _Control: {
                int guard_temperature = 
                          storage->property_get_int(Temperature);
                int current_temperature = cond->get_current_temperature();
                if (current_temperature > guard_temperature) {
                    state = _Cooling;
                } else if (current_temperature < guard_temperature) {
                    state = _Heating;
                } else {
                    state = _Waiting;
                }
                break;
            }
        }
    } while (state != _PowerOff);
    return ret;
}
\end{lstlisting}


\newpage
\section*{Модульное тестирование}\label{practical_work_4}
\addcontentsline{toc}{section}{Модульное тестирование}\lhead{Модульное тестирование}

\newpage
\section*{Обработка ошибок}\label{practical_work_5}
\addcontentsline{toc}{section}{Обработка ошибок}\lhead{Обработка ошибок}

\newpage
\section*{Логирование}\label{practical_work_6}
\addcontentsline{toc}{section}{Логирование}\lhead{Логирование}

Пример вывода лога можно посмотреть в приложении статьи А.~А.~Шалыто и Н.~И.~Туккель\cite{Shalito:Switch}.

\newpage
\section*{Эмулирование внешних устройств}\label{practical_work_7}
\addcontentsline{toc}{section}{Эмулирование внешних устройств}\lhead{Эмулирование внешних устройств}


\newpage
\chapter*{Лабораторные работы}\label{labs_works}
\addcontentsline{toc}{chapter}{Лабораторные работы}\lhead{Лабораторные работы}

\begin{enumerate}
  \item Описание объекта управления
  \item Описание модели \texttt{Promela}
  \item Структура проекта
  \item Модульное тестирование 
  \item Обработка ошибок
  \item Логирование
  \item Эмулирование внешних устройств
\end{enumerate}

\section*{Задания}\label{lab_work_formatting}
\addcontentsline{toc}{section}{Задания}
\lhead{Задания}

\begin{enumerate}
  \item Светофор с индикацией оставшегося времени(без детализации часов реального времени)
  \item Грузовой лифт(проверка грузоподьемности)
  \item Автомобильный манипулятор
  \item Супервизор(управление процессами)
  \item Автоматический нагреватель воды
  \item Дренажный насос
  \item Холодильник
  \item Турникет метро
  \item Банковский терминал выдачи наличных
  \item Парковка
  \item СКУД
  \item ЧПУ фрезер
\end{enumerate}

Номер работы вычисляется путем взятия номера по порядку вышей записи в журнале старосты по модулю 12 
и прибавлением к получившемуся числу 1 ($(N mod 12) + 1$).

\section*{Требования к оформлению кода}\label{lab_work_formatting}
\addcontentsline{toc}{section}{Требования к оформлению кода}
\lhead{Требования к оформлению кода} \label{style:cxx_code_style}

\subsection*{Отступы}\label{lab_work_formatting_tabs}
\addcontentsline{toc}{subsection}{Отступы}
\begin{itemize}
	\item [$*$] Для обозначения отступа используйте 4 пробела подряд;
	\item [$*$] Используйте проблелы, а не табуляцию.
\end{itemize}

\subsection*{Объявление переменных}\label{lab_work_formatting_variables}
\addcontentsline{toc}{subsection}{Объявление переменных}
\begin{itemize}
	\item [$*$] Объявляйте по одной переменной в строке;
	\item [$*$] Избегайте, если это возможно, коротких и запутанных названий переменных (Например: <<\texttt{a}>>, <<\texttt{rbarr}>>, <<\texttt{nughdeget}>>);
	\item [$*$] Односимвольные имена переменных подходят только для итераторов циклов, небольшого локального контекста и временных переменных. В остальных случаях имя переменной должно отражать ее назначение;
	\item [$*$] Заводите переменные только по мере необходимости:
	\begin{lstlisting}
		// Wrong
		int a, b;
		char *c, *d;
		// Correct
		int   height;
		int   width;
		char *name_of_this;
		char *name_of_that;
	\end{lstlisting}
	\item [$*$] Функции и переменные должны именоваться с прописной буквы, а если имя переменной или функции состоит из нескольких слов, то они разделяются нижним подчеркиванием;
	\item [$*$] Избегайте аббревиатур:
	\begin{lstlisting}
		// Wrong
		short Cntr;
		char  ITEM_DELIM = '\t';
		// Correct
		short counter;
		char  item_delimiter = '\t';
	\end{lstlisting}
\item [$*$] Имена классов, составных типов данных всегда начинаются с заглавной буквы.
\end{itemize}

\subsection*{Пробелы}\label{lab_work_formatting_whitespaces}
\addcontentsline{toc}{subsection}{Пробелы}
\begin{itemize}
	\item [$*$] Используйте пустые строки для логической группировки операторов, где это возможно;
	\item [$*$] Всегда используйте одну пустую строку в качестве разделителя;
	\item [$*$] Всегда используйте один пробел перед фигурной скобкой:
	\begin{lstlisting}
		// Wrong
		if(foo){
		}
		
		// Correct
		if (foo) {
		}
	\end{lstlisting}
	
	\item [$*$] Всегда ставьте один пробел после \texttt{*} или \texttt{\&}, если они стоят перед описанием типов. Но никогда не ставьте пробелы после \texttt{*} или \texttt{\&} и именем переменной:
	\begin{lstlisting}
		char *x;
		const Class &my_class;
		const char * const y = "hello";
	\end{lstlisting}
	\item [$*$] Бинарные операции отделяются пробелами с 2-х строн;
	\item [$*$] После преобразования типов не ставьте пробелов;
	\item [$*$] Избегайте проеобразования типов в стиле C, если ваш код на C++:
	\item [$*$] 
	\begin{lstlisting}
		// Wrong
		char * block_of_memory = (char *) malloc(data.size());
		// Correct
		char * block_of_memory = reinterpret_cast<char *>( malloc(data.size()) );
	\end{lstlisting}
\end{itemize}

\subsection*{Фигурные скобки}\label{lab_work_formatting_brices1}
\addcontentsline{toc}{subsection}{Фигурные скобки}
\begin{itemize}
	\item [$*$] Возьмите за основу расстановку открывающих фигурных скобок на одной строке с выражением, которому они предшествуют:
	\begin{lstlisting}
		// Wrong
		if (codec)
		{
		}
		
		// Correct
		if (codec) {
		}
	\end{lstlisting}
	\item [$*$] Исключение: Тело функции и описание класса всегда открывается фигурной скобкой, стоящей на тойже строке:
	\begin{lstlisting}
		static void foo(int g) {
		  fprintf(stdout, "foo: %i", g);
		}
		
		class Moo {
		};
	\end{lstlisting}
	\item [$*$] Используйте фигурные скобки в условиях, если тело условия в размере превышает одну линию, или тело условия достаточное сложное и выделение скобками действительно необходимо:
	\begin{lstlisting}
		// Wrong
		if (address.is_empty) {
		  return false;
		}
		
		for (int i = 0; i < 10; ++i) {
		  fprintf(stdout, "%i", i);
		}
		
		// Correct
		if (address.is_empty)
		  return true;
		  
		for (int i = 0; i < 10; ++i)
		  fprintf(stdout, "%i", i);
	\end{lstlisting}
	\item [$*$] Исключение 1: Используйте скобки, если родительское выражение состоит из нескольких строк или оберток:
	\begin{lstlisting}
		// Correct
		if (address.is_empty || !is_valid())
		    || !codec) {
			return false;
		}
	\end{lstlisting}
	\item [$*$] Исключение 2: Используйте фигурные скобки, когда тела ветвлений if-then-else занимают несколько строчек:
	\begin{lstlisting}
		// Wrong
		if (address.is_empty)
		  return false;
		else {
		  fprintf(stdout, "%s", address.c_str());
		  ++it;
		}
		
		// Correct
		if (address.isEmpty()) {
		  return false;
		} else {
		  fprintf(stdout, "%s", address.c_str());
		  ++it;
		}
		
		// Wrong
		if (a)
		  if (b)
		    ...
		  else
		    ...
	    
		// Correct
		// Wrong
		if (a) {
		  if (b)
		    ...
		  else
		    ...
		}
	\end{lstlisting}
	\item [$*$] Используйте фигурные скобки для обозначения пустого тела условия:
	\begin{lstlisting}
		// Wrong
		while (a);
		
		// Correct
		while (a) {}
	\end{lstlisting}
\end{itemize}

\subsection*{Круглые скобки}\label{lab_work_formatting_brices2}
\addcontentsline{toc}{subsection}{Круглые скобки}
\begin{itemize}
	\item [$*$] Используйте круглые скобки для группировки выражений:
	\begin{lstlisting}
		// Wrong
		if (a && b || c)
		
		// Correct
		if ((a && b) || c)
		
		// Wrong
		a + b & c
		// Correct
		(a + b) & c
	\end{lstlisting}
\end{itemize}

\subsection*{Использование конструкции \texttt{switch}}\label{lab_work_formatting_switch}
\addcontentsline{toc}{subsection}{Использование конструкции \texttt{switch}}
\begin{itemize}
	\item [$*$] Операторы \texttt{case} должны быть в одном столбце со \texttt{switch}
	\item [$*$] Каждый оператор \texttt{case} должен иметь закрывающий \texttt{break} (или \texttt{return}) или комментарий, котрой предполагает намеренное отсутсвие \texttt{break} или \texttt{return}:
	\begin{lstlisting}
		switch (my_enum) {
		case Value1:
		  do_somthing();
		  break;
		case Value2:
		  do_somthing_else();
		  // continue
		default:
		  default_handling();
		  break;
		}
	\end{lstlisting}
\end{itemize}

\subsection*{Разрыв строк}\label{lab_work_formatting_lines}
\addcontentsline{toc}{subsection}{Разрыв строк}
\begin{itemize}
	\item [$*$] Длина строки кода не должна превышать 100 символов. Если надо -- используйте разрыв строки.
	\item [$*$] Запятые помещаются в конец разорванной линии; операторы помещаются в начало новой строки. В зависимости от используемой вами \texttt{IDE}, оператор на конце разорванной строки можно проглядеть:
	\begin{lstlisting}
		// Correct
		if (long_expression
		    + other_long_expression
			+ other_other_long_expression) {
		}
		
		// Wrong
		if (long_expression +
		    other_long_expression +
			other_other_long_expression) {
		}
	\end{lstlisting}
\end{itemize}

\subsection*{Наследование и ключево слово \texttt{virtual}}\label{lab_work_formatting_virtual}
\addcontentsline{toc}{subsection}{Наследование и ключево слово \texttt{virtual}}
\begin{itemize}
	\item [$*$] При переопредлении \texttt{virtual}-метода, \emph{ни за что} не помещайте слово \texttt{virtual} в заголовочный файл.
\end{itemize}

\subsection*{Главное исключение}\label{lab_work_formatting_main}
\addcontentsline{toc}{subsection}{Главное исключение}
\begin{itemize}
	\item [$*$] Не бойтесь нарушать описанные выше правила, если вам кажется, что они только запутают ваш код.
\end{itemize}


\section*{Требования к оформлению работы}\label{lab_work_}
\addcontentsline{toc}{section}{Требования к оформлению работы}
\lhead{Требования к оформлению работы}

Лабораторная работа должна состоять из следующих необходимых компонент:
\begin{itemize}
  \item[ 1 лист ] Титульный лист
  \item[ 2 лист ] Описание объекта управления(цели и задачи объекта управления, функциональные требования, граничные условия, параметры и их назаначение). Пример \nameref{practical_work_1}.
  \item[ 3 лист ] Модель \texttt{Promela}. Пример \nameref{practical_work_2}.
  \item[ 4 лист ] Диаграмма переходов. Пример \nameref{practical_work_1}.
  \item[ 5 лист ] Описание модулей, компонент их взаимодействие.
\end{itemize}

Работа считается принятой если выполнены условия:
\begin{enumerate}
  \item Лабораторная работа представлена в бумажном виде и состоит, как минимум, из описанных выше компонент.
  \item На электронном носителе или в репозитории(\texttt{GitHub}) присутствуют в электронном виде:
    \begin{enumerate}
      \item Исходный код работы выполненный при помощи языка Си и оформленный в соответствии с требованиями \nameref{lab_work_formatting}
      \item Текст лабораторной работы в формате \texttt{doc} или \texttt{tex}
      \item Собранный исполняемы модуль приложения
      \item Проект вашей работы(файлы сборки - \texttt{cmake}, необходимые библиотеки - \texttt{googletest} как минимум, и т.д.)
    \end{enumerate}
  \item Ваша работа собирается на тестовом стенде, проходит верификацию модели, проходят все тесты(исполняется тестовый пример)
\end{enumerate}


\newpage
\chapter*{Приложение}\label{addons}
\addcontentsline{toc}{chapter}{Приложение}
\lhead{Приложение}

\section*{Б.П. Кузнецов об автоматном программировании}\label{kuznetcov_about}
\addcontentsline{toc}{section}{Б.П. Кузнецов об автоматном программировании}

Б. П. Кузнецов\footnote{к.т.н Концерн <<НПО <<Аврора>>, г. Санкт-Петербург}

Автоматное программирование ничуть не лучше любого другого ни по числу допускаемых ошибок, 
ни по срокам трудоемкости создания и отладки программ. В этом я убедился и в период активного 
использования как табличного, так и спискового (Switch, Любченко, Зюбин) задания автоматов 
в программах (к месту и не к месту) и в последующий период <<безавтоматного программирования>> 
с 2003 г. по нынешний день (да и до этого, когда <<вспомнил>> об автоматах). Более того, 
автоматное программирование доступно отнюдь не большинству, менее понятно и более трудоемко.

Перечислю типичные ошибки, сопровождающие автоматное программирование, как из собственного, 
так и заимствованного опыта, только лишь на примере составления диаграммы состояний конечного автомата:

\begin{enumerate}
  \item Не учтенные состояния автомата, вызванные незнанием предметной области; 
  \item Дублирование (избыточность) состояний, приводящее к непредсказуемому поведению программы; 
  \item Не учтенные переходы; 
  \item Лишние переходы; 
  \item Неверно ориентированные переходы; 
  \item Неортогональность входного алфавита; 
  \item Неверное назначение приоритетов переходов при неортогональном алфавите; 
  \item Не учтенные входные воздействия и неполнота входного алфавита; 
  \item Не полный учет букв входного алфавита; 
  \item Путаница, связанная с неверным отождествлением входных воздействий и буквами входного алфавита (наиболее распространенная ошибка); 
  \item Неверные булевы формулы, отождествляемые с буквами входного алфавита и помечающие переходы (см. п.6); 
  \item Не учтенные выходные воздействия, в особенности как реакция на ошибочное поведение управляемого объекта и самого управляющего автомата и связи управляющего и операционного автоматов с объектом управления; 
  \item Неверная пометка состояний и переходов буквами выходного алфавита; 
  \item Неверное отождествление букв выходного алфавита с выходными воздействиями; 
  \item Забытое обнуление или продление выходного воздействия; 
  \item Путаница в отметке переходов и состояний буквами выходного алфавита при использовании совмещенной модели (Мили и Мура) автоматов; 
  \item Не прослеживаются полные пути в диаграмме состояний; 
  \item Всевозможные ошибки в полных путях при использовании обратных связей в диаграмме состояний 
  \item Другие ошибки.
\end{enumerate}
Только одного этого перечня вполне достаточно, чтобы скомпрометировать <<непорочность>> автоматного программирования. 
И его мнимые достоинства связаны с тем, что <<каждый кулик хвалит свое болото>>, чем и я в свое время безапелляционно 
сообщал научному и инженерному сообществам в своих публикациях (см., например, мою статью <<Психология автоматного программирования>>).

PS. Мне кажется, что приведенный длинный перечень возможных ошибок только подтверждает такое достоинство 
автоматного программирования как формализация задания логики программы. Все изложенное можно 
проверять (автоматически и вручную), повышая качество программы. Интересно, как бы выглядел этот 
перечень для программ, которые пишутся традиционно? Мне кажется, что была бы одна строчка – в логике 
программы могут быть ошибки… Что с этим делать? А то, что автоматные программы, в отличие написанных 
иначе, удобно верифицировать методом Model Checking – это разве не достоинство. Графы переходов можно 
обсуждать с Заказчиками, а программы нельзя. И т. д., и т. п. А.А. Шалыто

\newpage
\section*{Описание опций \texttt{SPIN}}\label{spin_quick_REFERENCE}
\addcontentsline{toc}{section}{Описание опций \texttt{SPIN}}

\includepdf[pages=-]{spin-quick-reference.pdf}

\section*{\texttt{BNF} Языка \texttt{Promela}}\label{promela_BNF}
\addcontentsline{toc}{section}{\texttt{BNF} Языка \texttt{Promela}}
\begin{verbatim}
spec	: module [ module ] *

module	: proctype	/* proctype declaration */
	| init		/* init process       */
	| never		/* never claim        */
	| trace		/* event trace        */
	| utype		/* user defined types */
	| mtype		/* mtype declaration  */
	| decl_lst	/* global vars, chans */

proctype: [ active ] PROCTYPE name '(' [ decl_lst ]')'
	  [ priority ] [ enabler ] '{' sequence '}'

init	: INIT [ priority ] '{' sequence '}'

never	: NEVER	'{' sequence '}'

trace	: TRACE '{' sequence '}'

utype	: TYPEDEF name '{' decl_lst '}'

mtype	: MTYPE [ '=' ] '{' name [ ',' name ] * '}'

decl_lst: one_decl [ ';' one_decl ] *

one_decl: [ visible ] typename  ivar [',' ivar ] *

typename: BIT | BOOL | BYTE | SHORT | INT | MTYPE | CHAN
	| uname	/* user defined type names (see utype) */

active  : ACTIVE [ '[' const ']' ]	/* instantiation */

priority: PRIORITY const	/* simulation priority */

enabler : PROVIDED '(' expr ')'	/* execution constraint */

visible	: HIDDEN | SHOW

sequence: step [ ';' step ] *

step    : stmnt	[ UNLESS stmnt ]
	| decl_lst
	| XR varref [',' varref ] *
	| XS varref [',' varref ] *

ivar    : name [ '[' const ']' ] [ '=' any_expr | '=' ch_init ]

ch_init : '[' const ']' OF '{' typename [ ',' typename ] * '}'

varref	: name [ '[' any_expr ']' ] [ '.' varref ]

send    : varref '!' send_args		/* normal fifo send */
	| varref '!' '!' send_args	/* sorted send */

receive : varref '?' recv_args		/* normal receive */
	| varref '?' '?' recv_args	/* random receive */
	| varref '?' '<' recv_args '>'	/* poll with side-effect */
	| varref '?' '?' '<' recv_args '>'	/* ditto */

poll    : varref '?' '[' recv_args ']'	/* poll without side-effect */
	| varref '?' '?' '[' recv_args ']'	/* ditto */

send_args: arg_lst | any_expr '(' arg_lst ')'

arg_lst  : any_expr [ ',' any_expr ] *

recv_args: recv_arg [ ',' recv_arg ] *  |  recv_arg '(' recv_args ')'

recv_arg : varref | EVAL '(' varref ')' | [ '-' ] const

assign  : varref '=' any_expr	/* standard assignment */
	| varref '+' '+'	/* increment */
	| varref '-' '-'	/* decrement */

stmnt	: IF options FI		/* selection */
	| DO options OD		/* iteration */
	| FOR '(' range ')' '{' sequence '}'		/* iteration */
	| ATOMIC '{' sequence '}'	/* atomic sequence */
	| D_STEP '{' sequence '}'	/* deterministic atomic */
	| SELECT '(' range ')'	/* non-deterministic value selection */
	| '{' sequence '}'	/* normal sequence */
	| send
	| receive
	| assign
	| ELSE			/* used inside options */
	| BREAK			/* used inside iterations */
	| GOTO name
	| name ':' stmnt	/* labeled statement */
	| PRINT '(' string [ ',' arg_lst ] ')'
	| ASSERT expr
	| expr			/* condition */
	| c_code '{' ... '}'	/* embedded C code */
	| c_expr '{' ... '}'
	| c_decl '{' ... '}'
	| c_track '{' ... '}'
	| c_state '{' ... '}'

range	: varref ':' expr '..' expr
	| varref IN varref

options : ':' ':' sequence [ ':' ':' sequence ] *

andor	: '&' '&' | '|' '|'

binarop	: '+' | '-' | '*' | '/' | '%' | '&' | '^' | '|'
	| '>' | '<' | '>' '=' | '<' '=' | '=' '=' | '!' '='
	| '<' '<' | '>' '>' | andor

unarop	: '~' | '-' | '!'

any_expr: '(' any_expr ')'
	| any_expr binarop any_expr
	| unarop any_expr
	| '(' any_expr '-' '>' any_expr ':' any_expr ')'
	| LEN '(' varref ')'	/* nr of messages in chan */
	| poll
	| varref
	| const
	| TIMEOUT
	| NP_			/* non-progress system state */
	| ENABLED '(' any_expr ')'		/* refers to a pid */
	| PC_VALUE '(' any_expr ')'		/* refers to a pid */
	| name '[' any_expr ']' '@' name	/* refers to a pid */
	| RUN name '(' [ arg_lst ] ')' [ priority ]
	| get_priority( expr )			/* expr refers to a pid */
	| set_priority( expr , expr )		/* first expr refers to a pid */

expr	: any_expr
	| '(' expr ')'
	| expr andor expr
	| chanpoll '(' varref ')'	/* may not be negated */

chanpoll: FULL | EMPTY | NFULL | NEMPTY

string	: '"' [ any_ascii_char ] * '"'

uname	: name

name	: alpha [ alpha | number ] *

const	: TRUE | FALSE | SKIP | number [ number ] *

alpha	: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
	| 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
	| 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
	| 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
	| 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
	| 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'
	| '_'

number	: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
\end{verbatim}

\newpage
\section*{Примеры исходного кода}
\addcontentsline{toc}{section}{Примеры исходного кода}
\lstset{
  numbers = left,
  stepnumber = 1,
  numberstyle = \fontsize{11.5pt}{0.75em}\selectfont\monaco\color{comment},
}

\begin{lstlisting}[label={monitors_cxx_account_example}, caption={Пример \texttt{C}}]
printf("Hello")
\end{lstlisting}

%-----------------------------------------%
\newpage
\thispagestyle{empty}
\bibliographystyle{plain}
\bibliography{bibs}
%-----------------------------------------%
\newpage
\listoffigures
\end{document}
